<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blockchain &amp; Prediction Markets - Learn from Zero</title>
<style>
:root{--bg:#0a0e17;--sf:#111827;--sf2:#1a2235;--bd:#2a3550;--tx:#e2e8f0;--tx2:#94a3b8;--ac:#6366f1;--ac2:#818cf8;--gn:#22c55e;--gn2:#166534;--or:#f59e0b;--or2:#78350f;--rd:#ef4444;--cy:#22d3ee;--pk:#ec4899}
*{margin:0;padding:0;box-sizing:border-box}html{scroll-behavior:smooth}
body{font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:var(--bg);color:var(--tx);line-height:1.75;font-size:16px}
.sidebar{position:fixed;top:0;left:0;width:270px;height:100vh;background:var(--sf);border-right:1px solid var(--bd);overflow-y:auto;z-index:100;padding:20px 0;transition:transform .3s}
.sidebar.hidden{transform:translateX(-270px)}
.sb-logo{padding:0 16px 16px;border-bottom:1px solid var(--bd);margin-bottom:12px}
.sb-logo h2{font-size:15px;color:var(--ac2);letter-spacing:-.3px}.sb-logo span{font-size:11px;color:var(--tx2)}
.nav-day{padding:4px 16px;cursor:pointer;display:flex;align-items:center;gap:10px;font-size:13px;color:var(--tx2);transition:all .15s;border-left:3px solid transparent}
.nav-day:hover{color:var(--tx);background:var(--sf2)}.nav-day.active{color:var(--ac2);border-left-color:var(--ac);background:rgba(99,102,241,.08)}
.nav-day .nd-check{width:18px;height:18px;border-radius:50%;border:2px solid var(--bd);display:flex;align-items:center;justify-content:center;font-size:10px;flex-shrink:0}
.nav-day.done .nd-check{background:var(--gn);border-color:var(--gn);color:#fff}
.main{margin-left:270px;min-height:100vh;transition:margin-left .3s}.main.full{margin-left:0}
.topbar{position:sticky;top:0;z-index:50;background:rgba(10,14,23,.88);backdrop-filter:blur(12px);border-bottom:1px solid var(--bd);padding:10px 32px;display:flex;align-items:center;gap:16px}
.menu-btn{background:none;border:1px solid var(--bd);color:var(--tx);padding:5px 9px;border-radius:6px;cursor:pointer;font-size:15px}.menu-btn:hover{background:var(--sf2)}
.pbar{flex:1;max-width:350px}.ptrack{height:5px;background:var(--sf2);border-radius:3px;overflow:hidden}
.pfill{height:100%;background:linear-gradient(90deg,var(--ac),var(--cy));border-radius:3px;transition:width .5s}.plbl{font-size:11px;color:var(--tx2);margin-top:3px}
.content{max-width:820px;margin:0 auto;padding:32px 32px 100px}
.day{display:none}.day.active{display:block}
.dh{background:linear-gradient(135deg,var(--sf),var(--sf2));border:1px solid var(--bd);border-radius:14px;padding:28px;margin-bottom:28px;position:relative;overflow:hidden}
.dh::before{content:'';position:absolute;top:-40%;right:-15%;width:250px;height:250px;border-radius:50%;background:radial-gradient(circle,rgba(99,102,241,.12),transparent 70%)}
.dbg{display:inline-block;background:var(--ac);color:#fff;padding:3px 12px;border-radius:16px;font-size:11px;font-weight:700;letter-spacing:.5px;margin-bottom:10px}
.dh h1{font-size:26px;letter-spacing:-.5px;margin-bottom:6px}.dh p{color:var(--tx2);font-size:14px}
/* Sections */
.sec{background:var(--sf);border:1px solid var(--bd);border-radius:10px;margin-bottom:20px;overflow:hidden}
.sec-h{padding:16px 20px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;transition:all .15s;user-select:none}
.sec-h:hover{background:var(--sf2)}.sec-h h2{font-size:17px;letter-spacing:-.2px}.sec-h .tgl{color:var(--tx2);font-size:18px;transition:transform .2s}
.sec.open .sec-h{border-bottom:1px solid var(--bd)}.sec.open .tgl{transform:rotate(45deg)}
.sec-b{display:none;padding:20px}.sec.open .sec-b{display:block}
.sec-b h3{font-size:17px;margin:24px 0 10px;color:var(--ac2);padding-bottom:6px;border-bottom:1px solid var(--bd)}.sec-b h3:first-child{margin-top:0}
.sec-b h4{font-size:14px;margin:16px 0 6px;color:var(--cy);font-weight:700}.sec-b p{margin-bottom:12px;color:var(--tx2)}.sec-b strong{color:var(--tx)}
.sec-b ul,.sec-b ol{margin:0 0 14px 18px;color:var(--tx2)}.sec-b li{margin-bottom:5px}
.sec-b a{color:var(--ac2);text-decoration:none}.sec-b a:hover{text-decoration:underline}
/* Analogy box */
.analogy{background:linear-gradient(135deg,rgba(99,102,241,.06),rgba(34,211,238,.06));border:1px solid rgba(99,102,241,.2);border-radius:10px;padding:16px 18px;margin:14px 0;position:relative}
.analogy::before{content:'Real-World Analogy';position:absolute;top:-10px;left:14px;background:var(--sf);padding:0 8px;font-size:10px;text-transform:uppercase;letter-spacing:1px;color:var(--ac2);font-weight:700}
.analogy p{color:var(--tx);margin:4px 0;font-size:14px}
/* Callout */
.co{border-radius:8px;padding:14px 16px;margin:14px 0;font-size:14px;border-left:4px solid}
.co-i{background:rgba(99,102,241,.08);border-color:var(--ac)}.co-w{background:rgba(245,158,11,.08);border-color:var(--or)}.co-t{background:rgba(34,197,94,.08);border-color:var(--gn)}
.co-title{font-weight:700;margin-bottom:4px;color:var(--tx);font-size:13px}
/* Tables */
table{width:100%;border-collapse:collapse;margin:14px 0;font-size:13px}
th{background:var(--sf2);padding:8px 12px;text-align:left;font-size:11px;text-transform:uppercase;letter-spacing:.7px;color:var(--tx2);border-bottom:2px solid var(--bd)}
td{padding:8px 12px;border-bottom:1px solid var(--bd);color:var(--tx2)}tr:hover td{background:rgba(99,102,241,.03)}
/* Code */
pre{background:#0d1117;border:1px solid var(--bd);border-radius:7px;padding:14px;overflow-x:auto;margin:12px 0;font-size:12.5px;line-height:1.55}
code{font-family:'JetBrains Mono','Fira Code','Consolas',monospace;font-size:12.5px}
p code,li code{background:var(--sf2);padding:1px 5px;border-radius:3px;font-size:12.5px;color:var(--cy)}
.kw{color:#c678dd}.fn{color:#61afef}.st{color:#98c379}.cm{color:#5c6370;font-style:italic}.tp{color:#e5c07b}.num{color:#d19a66}
/* Diagram */
.dia{background:#0d1117;border:1px solid var(--bd);border-radius:7px;padding:16px;margin:12px 0;font-family:'JetBrains Mono',monospace;font-size:12.5px;line-height:1.5;overflow-x:auto;white-space:pre;color:var(--tx2)}
/* Exercises */
.ex-gate{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:24px;margin-top:32px}
.ex-gate h2{color:var(--or);font-size:18px;margin-bottom:4px}.ex-gate>p{color:var(--tx2);font-size:13px;margin-bottom:20px}
.ex-item{background:var(--sf2);border:1px solid var(--bd);border-radius:8px;padding:16px;margin-bottom:14px;position:relative}
.ex-item.completed{border-color:var(--gn);opacity:.7}.ex-item.completed::after{content:'Completed';position:absolute;top:12px;right:14px;font-size:11px;color:var(--gn);font-weight:700}
.ex-num{font-size:11px;color:var(--ac2);font-weight:700;text-transform:uppercase;letter-spacing:.8px;margin-bottom:8px}
.ex-item p,.ex-item label{color:var(--tx2);font-size:14px;margin-bottom:8px}
.ex-item strong{color:var(--tx)}
/* Quiz MCQ */
.mcq-opts{display:flex;flex-direction:column;gap:6px;margin:10px 0}
.mcq-opt{display:flex;align-items:center;gap:10px;padding:8px 12px;border:1px solid var(--bd);border-radius:6px;cursor:pointer;font-size:13px;color:var(--tx2);transition:all .15s}
.mcq-opt:hover{border-color:var(--ac);background:rgba(99,102,241,.05)}
.mcq-opt.selected{border-color:var(--ac);background:rgba(99,102,241,.1);color:var(--tx)}
.mcq-opt.correct{border-color:var(--gn);background:rgba(34,197,94,.1);color:var(--gn)}
.mcq-opt.wrong{border-color:var(--rd);background:rgba(239,68,68,.1);color:var(--rd)}
.mcq-opt input{display:none}
/* Text input */
.ex-input{width:100%;background:var(--bg);border:1px solid var(--bd);border-radius:6px;padding:10px;color:var(--tx);font-size:13px;font-family:inherit;resize:vertical;min-height:60px}
.ex-input:focus{outline:none;border-color:var(--ac)}
/* Buttons */
.ex-btn{background:var(--ac);color:#fff;border:none;padding:8px 18px;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;margin-top:8px;transition:all .15s}
.ex-btn:hover{background:var(--ac2)}.ex-btn:disabled{opacity:.4;cursor:default}
.ex-btn.submitted{background:var(--gn)}
/* Feedback */
.ex-fb{margin-top:10px;padding:10px 14px;border-radius:6px;font-size:13px;display:none}
.ex-fb.show{display:block}.ex-fb.pass{background:rgba(34,197,94,.1);color:var(--gn);border:1px solid rgba(34,197,94,.2)}
.ex-fb.fail{background:rgba(239,68,68,.1);color:var(--rd);border:1px solid rgba(239,68,68,.2)}
.ex-fb.info{background:rgba(99,102,241,.08);color:var(--ac2);border:1px solid rgba(99,102,241,.2)}
/* Day nav */
.dnav{display:flex;justify-content:space-between;margin-top:36px;padding-top:20px;border-top:1px solid var(--bd)}
.dnav button{background:var(--sf);border:1px solid var(--bd);color:var(--tx);padding:10px 20px;border-radius:7px;cursor:pointer;font-size:13px;transition:all .15s}
.dnav button:hover{background:var(--ac);border-color:var(--ac)}.dnav button:disabled{opacity:.3;cursor:default}.dnav button:disabled:hover{background:var(--sf);border-color:var(--bd)}
.dnav button.locked{background:var(--sf2);color:var(--tx2)}.dnav button.locked::before{content:'Lock '}
/* Landing */
.landing{text-align:center;padding:60px 16px}
.landing h1{font-size:36px;letter-spacing:-.8px;margin-bottom:10px}.landing h1 span{background:linear-gradient(135deg,var(--ac2),var(--cy));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.landing>p{color:var(--tx2);font-size:16px;max-width:560px;margin:0 auto 32px}
.dgrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:14px;max-width:760px;margin:0 auto}
.dc{background:var(--sf);border:1px solid var(--bd);border-radius:10px;padding:20px;text-align:left;cursor:pointer;transition:all .2s;position:relative;overflow:hidden}
.dc:hover{border-color:var(--ac);transform:translateY(-2px);box-shadow:0 6px 24px rgba(99,102,241,.15)}
.dc .dn{font-size:32px;font-weight:800;color:var(--ac);opacity:.25;position:absolute;top:8px;right:12px}.dc h3{font-size:13px;margin-bottom:4px}.dc p{font-size:11px;color:var(--tx2);margin:0}
.dc .dt{display:inline-block;margin-top:10px;font-size:10px;padding:2px 8px;border-radius:10px;background:var(--sf2);color:var(--tx2)}
.dc.locked{opacity:.5;cursor:not-allowed}.dc.locked:hover{border-color:var(--bd);transform:none;box-shadow:none}
/* Responsive */
@media(max-width:860px){.sidebar{transform:translateX(-270px)}.sidebar.visible{transform:translateX(0)}.main{margin-left:0!important}.content{padding:20px 14px 80px}.dh h1{font-size:20px}.landing h1{font-size:24px}}
::-webkit-scrollbar{width:5px}::-webkit-scrollbar-track{background:var(--bg)}::-webkit-scrollbar-thumb{background:var(--bd);border-radius:3px}
/* Scenario box */
.scenario{background:rgba(236,72,153,.06);border:1px solid rgba(236,72,153,.2);border-radius:10px;padding:16px 18px;margin:14px 0;position:relative}
.scenario::before{content:'Think About It';position:absolute;top:-10px;left:14px;background:var(--sf);padding:0 8px;font-size:10px;text-transform:uppercase;letter-spacing:1px;color:var(--pk);font-weight:700}
.scenario p{color:var(--tx);font-size:14px;margin:4px 0}
/* Match exercise */
.match-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:10px 0}.match-item{padding:8px 10px;background:var(--bg);border:1px solid var(--bd);border-radius:5px;font-size:12px;color:var(--tx2);cursor:pointer;text-align:center;transition:all .15s}
.match-item:hover{border-color:var(--ac)}.match-item.sel{border-color:var(--ac);background:rgba(99,102,241,.1)}.match-item.matched{border-color:var(--gn);background:rgba(34,197,94,.08);color:var(--gn)}
</style>
</head>
<body>
<!-- Sidebar -->
<nav class="sidebar" id="sidebar">
  <div class="sb-logo"><h2>Blockchain &amp; Prediction Markets</h2><span>Learn from Zero &bull; 8 Days</span></div>
  <div class="nav-day active" onclick="goDay(0)"><span class="nd-check"></span> Home</div>
  <div class="nav-day" onclick="goDay(1)" id="nav-1"><span class="nd-check">&#10003;</span> Day 1: What is Blockchain?</div>
  <div class="nav-day" onclick="goDay(2)" id="nav-2"><span class="nd-check">&#10003;</span> Day 2: Smart Contracts</div>
  <div class="nav-day" onclick="goDay(3)" id="nav-3"><span class="nd-check">&#10003;</span> Day 3: Prediction Markets</div>
  <div class="nav-day" onclick="goDay(4)" id="nav-4"><span class="nd-check">&#10003;</span> Day 4: Oracles</div>
  <div class="nav-day" onclick="goDay(5)" id="nav-5"><span class="nd-check">&#10003;</span> Day 5: Building Contracts</div>
  <div class="nav-day" onclick="goDay(6)" id="nav-6"><span class="nd-check">&#10003;</span> Day 6: Tokens &amp; Scaling</div>
  <div class="nav-day" onclick="goDay(7)" id="nav-7"><span class="nd-check">&#10003;</span> Day 7: Full System Design</div>
  <div class="nav-day" onclick="goDay(8)" id="nav-8"><span class="nd-check">&#10003;</span> Day 8: On/Off Ramp Payments</div>
</nav>

<!-- Main -->
<div class="main" id="main">
<div class="topbar">
  <button class="menu-btn" onclick="document.getElementById('sidebar').classList.toggle(window.innerWidth<=860?'visible':'hidden');document.getElementById('main').classList.toggle('full')">&#9776;</button>
  <span id="day-lbl" style="font-size:13px;color:var(--tx2)">Overview</span>
  <div class="pbar"><div class="ptrack"><div class="pfill" id="pfill" style="width:0%"></div></div><div class="plbl" id="plbl">0 / 7 days completed</div></div>
</div>
<div class="content">
<!-- ========== LANDING ========== -->
<div class="day active" id="day-0">
<div class="landing">
  <h1>Blockchain &amp;<br><span>Prediction Markets</span></h1>
  <p>An 8-day journey from "What is blockchain?" to "I can build a prediction market." No prior crypto knowledge needed. Every concept explained with real-world analogies. Progress unlocks only when you prove understanding.</p>
  <div class="dgrid">
    <div class="dc" onclick="goDay(1)"><div class="dn">1</div><h3>What is Blockchain?</h3><p>Like a Google Sheet the whole world shares but nobody can cheat on</p><span class="dt">Foundation</span></div>
    <div class="dc" onclick="goDay(2)"><div class="dn">2</div><h3>Smart Contracts</h3><p>Vending machines that run on the internet &mdash; insert money, get guaranteed results</p><span class="dt">Foundation</span></div>
    <div class="dc" onclick="goDay(3)"><div class="dn">3</div><h3>Prediction Markets</h3><p>A stock exchange where shares represent beliefs about future events</p><span class="dt">Core</span></div>
    <div class="dc" onclick="goDay(4)"><div class="dn">4</div><h3>Oracles</h3><p>The referee problem &mdash; who tells the blockchain what happened in the real world?</p><span class="dt">Core</span></div>
    <div class="dc" onclick="goDay(5)"><div class="dn">5</div><h3>Building Contracts</h3><p>Writing actual code: a prediction market from scratch in Solidity</p><span class="dt">Build</span></div>
    <div class="dc" onclick="goDay(6)"><div class="dn">6</div><h3>Tokens &amp; Scaling</h3><p>Digital casino chips, express highway lanes, and connecting to the real world</p><span class="dt">Build</span></div>
    <div class="dc" onclick="goDay(7)"><div class="dn">7</div><h3>System Design</h3><p>Putting it all together into a product people can actually use</p><span class="dt">Ship</span></div>
    <div class="dc" onclick="goDay(8)"><div class="dn">8</div><h3>On/Off Ramp Payments</h3><p>The bridge between your bank account and the blockchain &mdash; how real money flows in and out</p><span class="dt">Payments</span></div>
  </div>
</div>
</div>
<!-- ========== DAY 1 ========== -->
<div class="day" id="day-1">
<div class="dh"><span class="dbg">DAY 1</span><h1>What is Blockchain? The Foundation</h1><p>Forget everything you've heard about crypto. Let's start from the real problem blockchain solves.</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>The Problem: Why Do We Need This?</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Imagine you and 4 friends share an apartment. You split expenses &mdash; rent, groceries, electricity. Someone needs to keep track of who paid what and who owes whom.</p>

<div class="analogy"><p><strong>Option A: One person keeps the notebook.</strong> Sarah volunteers. She writes down every expense. But what if Sarah makes a mistake? What if she "forgets" to record that she owes money? You have to <em>trust</em> Sarah completely.</p></div>

<p>This is how the world works today. Your bank is "Sarah" &mdash; it keeps a private notebook (database) of who has how much money. You <strong>trust</strong> the bank not to cheat, lose your records, or block your transactions.</p>

<div class="analogy"><p><strong>Option B: Everyone keeps a copy of the notebook.</strong> Every time someone spends, ALL 5 roommates write it down in their own copy. If Sarah tries to cheat, the other 4 copies expose her lie. Nobody can alter the record because everyone has the same information.</p></div>

<p><strong>Option B is a blockchain.</strong> It's a shared notebook (ledger) where:</p>
<ul>
  <li><strong>Everyone has a copy</strong> &mdash; thousands of computers worldwide, not just one bank</li>
  <li><strong>Nobody can erase entries</strong> &mdash; once written, it's permanent (like writing in pen, not pencil)</li>
  <li><strong>Everyone can verify</strong> &mdash; you don't need to trust anyone; just check your copy</li>
  <li><strong>New entries need group approval</strong> &mdash; you can't write something without others confirming it</li>
</ul>

<div class="scenario"><p><strong>Why does this matter for prediction markets?</strong> Think about sports betting. You place a $100 bet on a website. But what if that website changes the odds after you bet? What if they refuse to pay when you win? What if they get hacked and your money disappears? With blockchain, your bet is recorded on a shared notebook nobody can tamper with. The payout rules are locked in advance. When you win, you get paid automatically &mdash; no company can block it.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Transactions: Writing in the Shared Notebook</h2><span class="tgl">+</span></div><div class="sec-b">
<p>A <strong>transaction</strong> is simply one entry in the shared notebook. "Alice paid Bob $50" is a transaction.</p>

<div class="analogy"><p><strong>Think of it like writing a check.</strong> When you write a check, you sign it (proving it's really you), you specify who gets the money and how much. A blockchain transaction works the same way &mdash; except instead of a pen signature, you use a <strong>digital signature</strong> (a secret mathematical key only you have).</p></div>

<p>Here's the key difference between chains:</p>
<table>
<thead><tr><th></th><th>Bitcoin</th><th>Ethereum</th><th>Solana</th></tr></thead>
<tbody>
<tr><td><strong>What can you write?</strong></td><td>Only money transfers<br><em>"Alice sends Bob 1 BTC"</em></td><td>Money transfers + programs<br><em>"Alice bets $100 on YES"</em></td><td>Money transfers + programs (faster)<br><em>Same as Ethereum but 1000x faster</em></td></tr>
<tr><td><strong>How fast?</strong></td><td>~10 minutes<br><em>Like sending a letter</em></td><td>~12 seconds<br><em>Like sending a text</em></td><td>~0.4 seconds<br><em>Like instant messaging</em></td></tr>
<tr><td><strong>Cost?</strong></td><td>$1-20</td><td>$0.50-50 (varies wildly)</td><td>$0.00025 (almost free)</td></tr>
</tbody>
</table>

<div class="co co-i"><div class="co-title">Why does speed matter for prediction markets?</div>Imagine you're betting on a live football match. If your bet takes 10 minutes to confirm (Bitcoin), the game situation has already changed. You need fast confirmation (Ethereum/Solana) so the bet reflects the current state.</div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Blocks: Bundling Entries into Pages</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Think of it like a book.</strong> Instead of writing transactions on loose paper, we bundle them into <strong>pages</strong> (blocks). Each page has a <strong>page number</strong> and a <strong>stamp</strong> that references the previous page. If someone rips out page 50, page 51's reference to page 50 breaks &mdash; everyone instantly knows something was tampered with.</p></div>

<p>A <strong>block</strong> contains:</p>
<ol>
<li>A batch of transactions (maybe 100-2000 entries)</li>
<li>A timestamp (when this page was written)</li>
<li>A reference to the previous block (the "chain" in blockchain)</li>
<li>A cryptographic fingerprint (hash) &mdash; a unique ID that changes if anything is altered</li>
</ol>

<h4>State: The Running Balance</h4>
<p>If the blockchain is the notebook of all transactions ever made, the <strong>state</strong> is the current summary &mdash; "who owns what right now."</p>

<div class="analogy"><p>Think of your bank statement. You don't re-read every transaction since you opened the account &mdash; you just check your <strong>current balance</strong>. That balance is the "state." But unlike a bank, the blockchain keeps the <em>entire history</em> so anyone can verify the state is correct.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Consensus: How Does Everyone Agree?</h2><span class="tgl">+</span></div><div class="sec-b">
<p>The hardest question in a shared notebook: <strong>who gets to write the next page?</strong> If everyone writes simultaneously, there's chaos. We need a fair system.</p>

<h4>Bitcoin's Answer: Proof of Work (The Puzzle Race)</h4>
<div class="analogy"><p>Imagine a classroom where the teacher says: "Whoever solves this extremely hard math puzzle first gets to write the next page." Thousands of students (miners) race to solve it. The winner writes the page, everyone else verifies it's correct, and the winner gets a reward (newly created Bitcoin). <strong>It's like a lottery where your "ticket" is computational work.</strong></p></div>
<p>Pros: Very secure. Cons: Wastes enormous electricity (like running millions of computers 24/7 to solve puzzles nobody needs).</p>

<h4>Ethereum's Answer: Proof of Stake (The Deposit System)</h4>
<div class="analogy"><p>Instead of a puzzle race, imagine a system where: you put down a <strong>$100,000 security deposit</strong> to become a page-writer. If you write truthfully, you earn fees. If you cheat, <strong>you lose your deposit</strong>. It's like how a landlord requires a security deposit &mdash; you behave well because your money is at stake.</p></div>
<p>Ethereum requires validators to deposit 32 ETH (~$50-100K). Every 12 seconds, a random validator is chosen to write the next block. A committee votes to confirm it. Cheaters get "slashed" (lose their deposit).</p>

<h4>Solana's Answer: Proof of History (The Timestamp Clock)</h4>
<div class="analogy"><p>Imagine all the page-writers have perfectly synchronized watches. Before anyone writes, a master clock stamps every transaction in order. Because everyone agrees on the exact sequence, they can work in parallel (like an assembly line) instead of waiting for each other. <strong>It's like a factory conveyor belt vs. everyone crowding around one desk.</strong></p></div>
<p>This is why Solana can process 65,000 transactions per second vs. Ethereum's ~30.</p>

<table>
<thead><tr><th></th><th>Bitcoin (PoW)</th><th>Ethereum (PoS)</th><th>Solana (PoH+PoS)</th></tr></thead>
<tbody>
<tr><td><strong>Analogy</strong></td><td>Puzzle race</td><td>Security deposit</td><td>Assembly line + deposit</td></tr>
<tr><td><strong>Who writes?</strong></td><td>Fastest puzzle solver</td><td>Random depositor</td><td>Scheduled leader</td></tr>
<tr><td><strong>Speed</strong></td><td>~7 tx/sec</td><td>~30 tx/sec</td><td>~65,000 tx/sec</td></tr>
<tr><td><strong>Energy use</strong></td><td>Enormous</td><td>99% less than Bitcoin</td><td>Minimal</td></tr>
<tr><td><strong>Can run prediction markets?</strong></td><td>No (too limited)</td><td>Yes (most popular)</td><td>Yes (fastest &amp; cheapest)</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Why Blockchain for Prediction Markets? (Summary)</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Let's compare a traditional betting site vs. a blockchain prediction market:</p>
<table>
<thead><tr><th>Problem</th><th>Traditional (e.g., Betfair)</th><th>Blockchain (e.g., Polymarket)</th></tr></thead>
<tbody>
<tr><td><strong>Can they freeze my money?</strong></td><td>Yes, anytime</td><td>No &mdash; funds are in a smart contract, not a company's bank</td></tr>
<tr><td><strong>Can they change the rules?</strong></td><td>Yes, read the fine print</td><td>No &mdash; rules are code, visible to everyone</td></tr>
<tr><td><strong>What if they go bankrupt?</strong></td><td>Your money may be gone</td><td>Funds are on-chain, independent of any company</td></tr>
<tr><td><strong>Do I need to trust them?</strong></td><td>Completely</td><td>No &mdash; trust the code, which is public and auditable</td></tr>
<tr><td><strong>Who decides the outcome?</strong></td><td>The company</td><td>Decentralized oracles (we'll cover in Day 4)</td></tr>
<tr><td><strong>Is it transparent?</strong></td><td>No &mdash; proprietary systems</td><td>Yes &mdash; all trades and funds are publicly visible</td></tr>
</tbody>
</table>

<div class="co co-t"><div class="co-title">The One-Sentence Summary</div>Blockchain lets you build betting markets where the rules are enforced by math instead of trust, the money is held by code instead of a company, and the results are verified by thousands of computers instead of one organization.</div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Further Reading</h2><span class="tgl">+</span></div><div class="sec-b">
<ul>
<li><a href="https://bitcoin.org/en/how-it-works" target="_blank">Bitcoin.org: How It Works</a> &mdash; the original Bitcoin explanation</li>
<li><a href="https://ethereum.org/en/what-is-ethereum/" target="_blank">Ethereum.org: What is Ethereum?</a> &mdash; official beginner guide</li>
<li><a href="https://solana.com/docs" target="_blank">Solana Docs</a> &mdash; overview of Solana's architecture</li>
<li><a href="https://ethereum.org/en/developers/docs/intro-to-ethereum/" target="_blank">Ethereum Dev Docs: Intro</a> &mdash; technical introduction</li>
</ul>
</div></div>

<!-- DAY 1 EXERCISES -->
<div class="ex-gate" id="ex-1">
<h2>Day 1 Exercises</h2>
<p>Complete ALL exercises below to unlock Day 2. Your progress is saved automatically.</p>

<div class="ex-item" id="ex-1-1">
<div class="ex-num">Exercise 1 of 5 &mdash; Multiple Choice</div>
<p><strong>In the roommate notebook analogy, what is the main advantage of everyone keeping their own copy?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'1-1','a')">a) It's faster to write things down</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'1-1','b')">b) No single person can cheat because others can verify</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'1-1','c')">c) It uses less paper</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'1-1','d')">d) Only one person needs to check for errors</div>
</div>
<button class="ex-btn" onclick="checkMCQ('1-1','b','That\'s right! When everyone has a copy, no single person can alter the record without being caught. This is the core idea of decentralization.')">Submit Answer</button>
<div class="ex-fb" id="fb-1-1"></div>
</div>

<div class="ex-item" id="ex-1-2">
<div class="ex-num">Exercise 2 of 5 &mdash; Multiple Choice</div>
<p><strong>You want to build a prediction market where users make small, frequent bets on live sports events. Which blockchain would be the worst choice and why?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'1-2','a')">a) Solana &mdash; because it's too fast</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'1-2','b')">b) Ethereum &mdash; because it can't run programs</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'1-2','c')">c) Bitcoin &mdash; because it's slow, expensive, and can't run smart contracts</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'1-2','d')">d) All of them are equally good</div>
</div>
<button class="ex-btn" onclick="checkMCQ('1-2','c','Correct! Bitcoin takes ~10 minutes per confirmation, costs $1-20+ per transaction, and its scripting language can\'t support the complex logic a prediction market needs. Ethereum and Solana are far better suited.')">Submit Answer</button>
<div class="ex-fb" id="fb-1-2"></div>
</div>

<div class="ex-item" id="ex-1-3">
<div class="ex-num">Exercise 3 of 5 &mdash; Short Answer</div>
<p><strong>In your own words, explain what "consensus" means in blockchain. Use the analogy of a group of friends deciding where to eat dinner.</strong></p>
<textarea class="ex-input" id="inp-1-3" placeholder="Write at least 2-3 sentences..."></textarea>
<button class="ex-btn" onclick="checkText('1-3',30,'Great answer! Consensus in blockchain is like a group of friends voting on a restaurant. Everyone must agree (or a majority must agree) before the decision is final. No single person can force the group to go somewhere. In Proof of Work, it\'s like saying \'whoever finds the restaurant with the best Yelp review first gets to decide\' &mdash; in Proof of Stake, it\'s like \'whoever puts the most money on the table for their choice gets more voting power, but loses it if the restaurant turns out to be terrible.\'')">Submit Answer</button>
<div class="ex-fb" id="fb-1-3"></div>
</div>

<div class="ex-item" id="ex-1-4">
<div class="ex-num">Exercise 4 of 5 &mdash; Scenario</div>
<p><strong>Scenario:</strong> Your friend says "Why not just use a regular database? It's faster and cheaper than blockchain." <strong>Give them 3 specific reasons why a prediction market needs blockchain instead of a regular database.</strong></p>
<textarea class="ex-input" id="inp-1-4" placeholder="List 3 reasons with brief explanations..."></textarea>
<button class="ex-btn" onclick="checkText('1-4',50,'Excellent! Key reasons include: (1) Trustlessness &mdash; users don\'t have to trust the company running the market; the rules are enforced by public code. (2) Censorship resistance &mdash; no government or company can shut down the market or freeze user funds. (3) Transparency &mdash; all bets, odds, and payouts are publicly verifiable. Other valid reasons: immutability (the company can\'t change rules after bets are placed), no single point of failure (the market survives even if the company disappears), and programmable payouts (smart contracts automatically pay winners).')">Submit Answer</button>
<div class="ex-fb" id="fb-1-4"></div>
</div>

<div class="ex-item" id="ex-1-5">
<div class="ex-num">Exercise 5 of 5 &mdash; Exploration Proof</div>
<p><strong>Go to <a href="https://etherscan.io" target="_blank">etherscan.io</a> and find ANY recent transaction.</strong> Paste the transaction hash (the long string starting with 0x...) below. Then describe in 1-2 sentences what you observe about that transaction (who sent it, how much gas was used, etc.)</p>
<textarea class="ex-input" id="inp-1-5" placeholder="Transaction hash: 0x...\n\nWhat I observed: ..."></textarea>
<button class="ex-btn" onclick="checkText('1-5',30,'Nice work! You\'ve just read from the actual Ethereum blockchain. Every single transaction ever made is publicly visible like this. The gas used represents the computational cost of that transaction. The \'from\' and \'to\' fields are wallet addresses &mdash; pseudonymous but transparent. This is the transparency that makes blockchain-based prediction markets trustworthy.')">Submit Answer</button>
<div class="ex-fb" id="fb-1-5"></div>
</div>

</div><!-- /ex-gate -->

<div class="dnav">
<button disabled>&larr; Previous</button>
<button onclick="goDay(2)" id="next-1" disabled>Day 2: Smart Contracts &rarr;</button>
</div>
</div>
<!-- ========== DAY 2 ========== -->
<div class="day" id="day-2">
<div class="dh"><span class="dbg">DAY 2</span><h1>Smart Contracts &mdash; The Vending Machine on the Internet</h1><p>Code that runs itself, holds money, and enforces rules without any human in the loop.</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>What is a Smart Contract? (No Code Yet)</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>A vending machine.</strong> You put in $2, press B4, and a bag of chips drops out. The machine doesn't care who you are, what time it is, or whether it likes you. The rules are mechanical: correct money + valid selection = product dispensed. No human cashier needed. No negotiation possible. No refund unless the machine is programmed for it.</p></div>

<p>A <strong>smart contract</strong> is a vending machine that lives on the blockchain. Instead of chips, it dispenses money, tokens, or services. Instead of physical buttons, it responds to digital transactions.</p>

<p>For a prediction market, imagine a smart contract that says:</p>
<div class="dia">IF user sends $100 and picks "YES on Team A winning"
  THEN record the bet and hold the $100

WHEN the game ends AND the oracle reports "Team A won"
  THEN send each YES bettor their proportional share of all the money</div>

<p>Once this contract is deployed to the blockchain:</p>
<ul>
<li><strong>Nobody can change the rules</strong> &mdash; not even the person who created it</li>
<li><strong>Nobody can steal the money</strong> &mdash; it's locked in the contract, not in anyone's bank account</li>
<li><strong>Payouts are automatic</strong> &mdash; winners get paid by code, not by a company deciding to honor its commitments</li>
</ul>

<div class="scenario"><p><strong>Real-world comparison:</strong> In 2022, FTX (a centralized crypto exchange) collapsed and users lost $8 billion because the company secretly moved their deposits. With a smart contract, this is <em>impossible</em> &mdash; the funds sit in publicly auditable code on the blockchain, not in a CEO's control.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>The Ethereum Virtual Machine (EVM): The Computer Inside Ethereum</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Smart contracts need a computer to run on. Ethereum's computer is called the <strong>EVM</strong> (Ethereum Virtual Machine).</p>

<div class="analogy"><p><strong>Think of the EVM as a global calculator.</strong> Every one of the ~7,000 Ethereum computers worldwide runs the exact same calculation for every transaction. They all get the exact same answer. This guarantees that no single computer can lie about the result &mdash; because 6,999 others would disagree.</p></div>

<h4>The Three Memory Areas (Where Data Lives)</h4>
<table>
<thead><tr><th>Area</th><th>Real-World Analogy</th><th>What It's For</th><th>Cost</th></tr></thead>
<tbody>
<tr><td><strong>Storage</strong></td><td>A filing cabinet (permanent records)</td><td>User balances, bet amounts, market state</td><td>Very expensive &mdash; like renting a safe deposit box</td></tr>
<tr><td><strong>Memory</strong></td><td>A whiteboard (erased after each session)</td><td>Temporary calculations during a transaction</td><td>Moderate</td></tr>
<tr><td><strong>Stack</strong></td><td>Sticky notes (used and discarded immediately)</td><td>Quick math during individual operations</td><td>Cheap</td></tr>
</tbody>
</table>

<h4>Gas: The "Postage Stamp" for Transactions</h4>
<div class="analogy"><p><strong>Think of gas like postage.</strong> Sending a postcard (simple transfer) costs one stamp. Sending a heavy package (complex smart contract interaction) costs more stamps. If you don't put enough stamps on, the post office rejects it. Gas works the same way &mdash; complex operations cost more gas (paid in ETH), and if you don't provide enough, the transaction fails (but you still pay for the gas used trying).</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Solidity: Reading Smart Contract Code</h2><span class="tgl">+</span></div><div class="sec-b">
<p><strong>Solidity</strong> is the programming language for Ethereum smart contracts. You don't need to write it yet &mdash; but let's learn to <em>read</em> it. Think of this as learning to read a restaurant menu in a foreign language &mdash; you don't need to cook the food, just understand what's being offered.</p>

<p>Here's a dead-simple prediction market. I'll explain every line:</p>
<pre><code><span class="cm">// This contract accepts YES and NO bets, then pays winners</span>
<span class="kw">contract</span> <span class="tp">SimpleBet</span> {

    <span class="cm">// WHO created this market? (stored permanently)</span>
    <span class="tp">address</span> <span class="kw">public</span> admin;

    <span class="cm">// HOW MUCH is in the YES pile and NO pile?</span>
    <span class="tp">uint256</span> <span class="kw">public</span> yesPool;  <span class="cm">// total $ bet on YES</span>
    <span class="tp">uint256</span> <span class="kw">public</span> noPool;   <span class="cm">// total $ bet on NO</span>

    <span class="cm">// WHO bet how much on YES? (like a lookup table)</span>
    <span class="kw">mapping</span>(<span class="tp">address</span> =&gt; <span class="tp">uint256</span>) <span class="kw">public</span> yesBets;
    <span class="cm">// mapping = a phonebook: look up any person, see their bet</span>

    <span class="cm">// IS the market still open?</span>
    <span class="tp">bool</span> <span class="kw">public</span> resolved; <span class="cm">// false=open, true=decided</span>
    <span class="tp">bool</span> <span class="kw">public</span> outcome;  <span class="cm">// true=YES won, false=NO won</span>

    <span class="cm">// BET ON YES: user sends money with this call</span>
    <span class="kw">function</span> <span class="fn">betYes</span>() <span class="kw">external payable</span> {
        <span class="kw">require</span>(!resolved);  <span class="cm">// BOUNCER: "market must be open"</span>
        <span class="kw">require</span>(msg.value &gt; <span class="num">0</span>); <span class="cm">// BOUNCER: "must send money"</span>
        yesBets[msg.sender] += msg.value; <span class="cm">// record the bet</span>
        yesPool += msg.value; <span class="cm">// add to YES pile</span>
    }

    <span class="cm">// RESOLVE: admin declares the outcome</span>
    <span class="kw">function</span> <span class="fn">resolve</span>(<span class="tp">bool</span> _outcome) <span class="kw">external</span> {
        <span class="kw">require</span>(msg.sender == admin); <span class="cm">// only admin can do this</span>
        resolved = <span class="kw">true</span>;
        outcome = _outcome;
    }
}</code></pre>

<h4>Key Vocabulary (Jargon Decoder)</h4>
<table>
<thead><tr><th>Code Term</th><th>English Translation</th><th>Real-World Analogy</th></tr></thead>
<tbody>
<tr><td><code>address</code></td><td>A user's unique ID</td><td>Like an email address but for money</td></tr>
<tr><td><code>mapping</code></td><td>A lookup table</td><td>Like a phone book: name &rarr; number</td></tr>
<tr><td><code>msg.sender</code></td><td>Who is calling this function right now?</td><td>Caller ID on a phone</td></tr>
<tr><td><code>msg.value</code></td><td>How much money did they send with this call?</td><td>Cash in the envelope</td></tr>
<tr><td><code>require()</code></td><td>A bouncer: if condition is false, reject everything</td><td>"No ID, no entry"</td></tr>
<tr><td><code>payable</code></td><td>This function can receive money</td><td>A cash register (vs. an info desk)</td></tr>
<tr><td><code>public</code></td><td>Anyone can read this value</td><td>A public bulletin board</td></tr>
<tr><td><code>external</code></td><td>Can only be called from outside the contract</td><td>A customer-facing window</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Ethereum vs Solana: Two Different Architectures</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Ethereum is like a row of food trucks.</strong> Each truck (smart contract) has its own kitchen, its own ingredients, and its own recipes &mdash; all in one vehicle. If you want 50 different markets, you need 50 trucks.</p>
<p><strong>Solana is like a central kitchen with separate serving windows.</strong> One kitchen (program) handles all the cooking. Each serving window (data account) keeps its own orders and plates. Want 50 markets? One kitchen, 50 windows. Much more efficient.</p></div>

<table>
<thead><tr><th>Aspect</th><th>Ethereum</th><th>Solana</th></tr></thead>
<tbody>
<tr><td><strong>Language</strong></td><td>Solidity (JavaScript-like)</td><td>Rust (systems programming)</td></tr>
<tr><td><strong>Code + Data</strong></td><td>Combined in one contract</td><td>Separated: program (code) + accounts (data)</td></tr>
<tr><td><strong>Upgrades</strong></td><td>Locked forever by default</td><td>Upgradeable by default</td></tr>
<tr><td><strong>Cost per bet</strong></td><td>$0.50-5.00 (L2: $0.01)</td><td>$0.00025</td></tr>
<tr><td><strong>For prediction markets</strong></td><td>Most mature ecosystem (Polymarket uses this)</td><td>Cheapest &amp; fastest (Drift BET uses this)</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Further Reading</h2><span class="tgl">+</span></div><div class="sec-b">
<ul>
<li><a href="https://ethereum.org/en/developers/docs/smart-contracts/" target="_blank">Ethereum.org: Smart Contracts</a></li>
<li><a href="https://docs.soliditylang.org/en/latest/" target="_blank">Solidity Documentation</a></li>
<li><a href="https://solana.com/docs/core/programs" target="_blank">Solana: Programs</a></li>
<li><a href="https://remix.ethereum.org" target="_blank">Remix IDE</a> &mdash; try Solidity in your browser</li>
</ul>
</div></div>

<!-- DAY 2 EXERCISES -->
<div class="ex-gate" id="ex-2">
<h2>Day 2 Exercises</h2>
<p>Complete ALL exercises to unlock Day 3.</p>

<div class="ex-item" id="ex-2-1">
<div class="ex-num">Exercise 1 of 5 &mdash; Multiple Choice</div>
<p><strong>In the vending machine analogy, what does "deploying a smart contract" correspond to?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'2-1','a')">a) Putting money into the machine</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'2-1','b')">b) Installing and plugging in the machine so anyone can use it</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'2-1','c')">c) Pressing a button to get a product</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'2-1','d')">d) Refilling the machine with products</div>
</div>
<button class="ex-btn" onclick="checkMCQ('2-1','b','Correct! Deploying a smart contract is like installing the vending machine in a public place. Once it\'s there, anyone can interact with it, and the rules (what each button does) are fixed. You can\'t change the wiring after installation.')">Submit Answer</button>
<div class="ex-fb" id="fb-2-1"></div>
</div>

<div class="ex-item" id="ex-2-2">
<div class="ex-num">Exercise 2 of 5 &mdash; Code Reading</div>
<p><strong>Look at the SimpleBet contract above. What happens if someone calls <code>betYes()</code> after the market is resolved?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'2-2','a')">a) Their bet is accepted but they can't win</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'2-2','b')">b) The transaction is rejected and their money is returned</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'2-2','c')">c) The contract crashes</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'2-2','d')">d) The admin gets notified</div>
</div>
<button class="ex-btn" onclick="checkMCQ('2-2','b','Correct! The line require(!resolved) acts as a bouncer. If resolved is true (market is decided), the require fails and the entire transaction is reverted &mdash; meaning the user\'s money is returned. This is how smart contracts enforce rules automatically.')">Submit Answer</button>
<div class="ex-fb" id="fb-2-2"></div>
</div>

<div class="ex-item" id="ex-2-3">
<div class="ex-num">Exercise 3 of 5 &mdash; Analogy Building</div>
<p><strong>Gas on Ethereum is like postage stamps. Come up with your OWN real-world analogy for gas that explains: (1) why it exists, (2) why complex operations cost more, and (3) what happens if you don't provide enough.</strong></p>
<textarea class="ex-input" id="inp-2-3" placeholder="My analogy for gas is..."></textarea>
<button class="ex-btn" onclick="checkText('2-3',40,'Great thinking! Some other analogies people use: Gas is like fuel in a car (exists to power the engine, highway driving costs less than city driving, and if you run out you stop but still used what you burned). Or: gas is like hiring movers (simple move = cheap, complex move with a piano = expensive, and if you don\'t pay enough they stop mid-job but keep what you paid).')">Submit Answer</button>
<div class="ex-fb" id="fb-2-3"></div>
</div>

<div class="ex-item" id="ex-2-4">
<div class="ex-num">Exercise 4 of 5 &mdash; Critical Thinking</div>
<p><strong>The SimpleBet contract has a problem: only the admin can call <code>resolve()</code>. Why is this a problem for a prediction market? What could go wrong? (Think about trust.)</strong></p>
<textarea class="ex-input" id="inp-2-4" placeholder="The problem with admin-only resolution is..."></textarea>
<button class="ex-btn" onclick="checkText('2-4',30,'Spot on! If only the admin can resolve, you\'re back to the trust problem we\'re trying to solve. The admin could: (1) resolve in favor of their own bets, (2) refuse to resolve so nobody gets paid, (3) be bribed to declare the wrong outcome. This is why we need ORACLES (Day 4) &mdash; decentralized systems that report outcomes without trusting any single person.')">Submit Answer</button>
<div class="ex-fb" id="fb-2-4"></div>
</div>

<div class="ex-item" id="ex-2-5">
<div class="ex-num">Exercise 5 of 5 &mdash; Exploration</div>
<p><strong>Go to <a href="https://remix.ethereum.org" target="_blank">Remix IDE</a> (a free in-browser Solidity editor). Create a new file, paste the SimpleBet contract code, and click "Compile." Did it compile successfully?</strong> Paste a screenshot description or the compiler output below.</p>
<textarea class="ex-input" id="inp-2-5" placeholder="What happened when I compiled: ..."></textarea>
<button class="ex-btn" onclick="checkText('2-5',15,'Great work! You\'ve just compiled your first smart contract. Remix is where all Solidity developers start. The compilation step turns human-readable Solidity into EVM bytecode &mdash; the machine code that every Ethereum node can execute. In Day 5, we\'ll build a full production-grade prediction market contract.')">Submit Answer</button>
<div class="ex-fb" id="fb-2-5"></div>
</div>
</div>

<div class="dnav">
<button onclick="goDay(1)">&larr; Day 1</button>
<button onclick="goDay(3)" id="next-2" disabled>Day 3: Prediction Markets &rarr;</button>
</div>
</div>
<!-- ========== DAY 3 ========== -->
<div class="day" id="day-3">
<div class="dh"><span class="dbg">DAY 3</span><h1>Prediction Markets &mdash; A Stock Exchange for Beliefs</h1><p>How do you turn opinions about the future into tradeable assets with real prices?</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>How Prediction Markets Work (No Blockchain Yet)</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Imagine a stock market, but instead of companies, you're trading shares in future events.</strong></p>
<p>The question: "Will it rain tomorrow?"<br>
You can buy a <strong>YES share</strong> for $0.70 or a <strong>NO share</strong> for $0.30.<br>
YES + NO always = $1.00.</p>
<p>If it rains: your YES share is worth $1.00 (you profit $0.30).<br>
If it doesn't: your YES share is worth $0.00 (you lose $0.70).</p>
<p><strong>The price IS the probability.</strong> A YES share at $0.70 means the market collectively believes there's a 70% chance of rain.</p></div>

<h4>Why Are Prediction Markets Accurate?</h4>
<div class="analogy"><p><strong>Think of a jar of jellybeans.</strong> If you ask one person to guess the number, they'll probably be way off. But if you ask 1,000 people and average their guesses, the answer is shockingly close to correct. This is the "wisdom of crowds." Prediction markets work the same way &mdash; except instead of guessing for free, people put <em>real money</em> on their beliefs. Money makes people honest and careful.</p></div>

<p>If a trader knows something the market doesn't (say, they have insider weather data), they'll buy underpriced shares, pushing the price toward the true probability. <strong>Good information literally flows into the price.</strong></p>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>The Conditional Token Framework (CTF): Digital Betting Chips</h2><span class="tgl">+</span></div><div class="sec-b">
<p>On blockchain prediction markets, your bets are represented as <strong>tokens</strong> (digital assets). The system used by Polymarket (the biggest platform, $18B+ traded) is called the <strong>Conditional Token Framework</strong>.</p>

<div class="analogy"><p><strong>Think of a casino.</strong> You walk in with $100 cash. At the cashier, you exchange it for chips: 1 red chip (YES) + 1 blue chip (NO). You can then trade these chips with other players. After the event, the casino accepts winning chips for $1 each, and losing chips become worthless.</p></div>

<h4>The Three Operations</h4>
<div class="dia">SPLIT:  $1 USDC    1 YES chip  +  1 NO chip
        (buy in)       (your position tokens)

MERGE:  1 YES chip + 1 NO chip    $1 USDC
        (cash out early, no matter what happens)

REDEEM: 1 Winning chip    $1 USDC
        (after event is decided)</div>

<p><strong>Key insight:</strong> Because 1 YES + 1 NO can always be merged back into $1, the prices <em>must</em> add up to $1. If YES is $0.70, NO must be $0.30. If they don't add up, traders instantly profit by exploiting the gap (arbitrage), which pushes prices back in line.</p>

<div class="scenario"><p><strong>Walk through an example:</strong></p>
<p>1. Alice has $100. She SPLITS it into 100 YES + 100 NO tokens.<br>
2. Alice thinks YES will win. She sells her 100 NO tokens to Bob at $0.40 each. Alice gets $40.<br>
3. Net cost for Alice: $100 spent - $40 received = <strong>$60 invested in YES</strong>.<br>
4. Bob has 100 NO tokens that cost him <strong>$40</strong>.<br>
5. The event resolves <strong>YES</strong>.<br>
6. Alice redeems 100 YES tokens &rarr; gets $100. <strong>Profit: $40.</strong><br>
7. Bob's NO tokens are worth $0. <strong>Loss: $40.</strong></p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Price Discovery: How Do Prices Get Set?</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Someone needs to match buyers and sellers and set prices. There are several approaches:</p>

<h4>1. Order Book (CLOB) &mdash; Used by Polymarket</h4>
<div class="analogy"><p><strong>Like a stock exchange.</strong> Buyers post "I'll buy YES at $0.68" and sellers post "I'll sell YES at $0.72." When a buyer and seller agree on a price, the trade happens. The gap between the best buy and sell price is the "spread." Professional traders ("market makers") keep this gap small by posting orders on both sides.</p></div>
<p>Polymarket matches orders off-chain (fast) and settles them on-chain (trustless). Best for popular markets with lots of traders.</p>

<h4>2. LMSR (Logarithmic Market Scoring Rule) &mdash; The Auto-Bookie</h4>
<div class="analogy"><p><strong>Imagine a bookmaker who ALWAYS takes your bet</strong>, no matter how weird. But the more people bet on one side, the more expensive it gets. It's like a surge pricing system &mdash; if everyone wants YES, the YES price goes up automatically. The bookmaker (the contract) absorbs losses to provide liquidity, funded by the market creator.</p></div>
<p>Great for new markets with few traders. No need to wait for a counterparty.</p>

<h4>3. CPMM (Constant Product) &mdash; Uniswap-style</h4>
<div class="analogy"><p><strong>A swimming pool with two types of water.</strong> The pool always maintains a fixed "volume" (x &times; y = constant). If you add YES tokens (buying NO), the pool adjusts both levels. Problem for prediction markets: as the event approaches resolution, one token goes to $1 and the other to $0, causing massive losses for the pool providers.</p></div>

<h4>4. pm-AMM &mdash; State of the Art (Paradigm, 2024)</h4>
<p>A new design that concentrates liquidity around 50% probability (where most trading happens) and automatically withdraws liquidity as the event approaches. Solves the "pool provider gets wrecked" problem.</p>

<table>
<thead><tr><th>Method</th><th>Analogy</th><th>Best For</th><th>Weakness</th></tr></thead>
<tbody>
<tr><td><strong>Order Book</strong></td><td>Stock exchange</td><td>Popular, high-volume markets</td><td>Empty order books in new markets</td></tr>
<tr><td><strong>LMSR</strong></td><td>Always-on bookmaker</td><td>New, low-liquidity markets</td><td>Creator subsidizes losses</td></tr>
<tr><td><strong>CPMM</strong></td><td>Swimming pool</td><td>Established markets</td><td>Huge losses at resolution</td></tr>
<tr><td><strong>pm-AMM</strong></td><td>Smart pool that shrinks near deadline</td><td>All prediction markets</td><td>Newer, less battle-tested</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>How Polymarket Actually Works (End to End)</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="dia">1. You deposit USDC (US dollar stablecoin) from your bank
                    
2. USDC bridges to Polygon (a cheaper, faster version of Ethereum)
                    
3. You browse markets: "Will Bitcoin hit $100k by March?"
                    
4. You click "Buy YES at $0.65"  your USDC splits into YES+NO tokens
    the order book matches your buy with someone's sell
    the YES tokens land in your wallet
                    
5. You wait. The price moves based on news and other traders.
   You can sell your YES tokens anytime on the order book.
                    
6. March arrives. Bitcoin is at $105k.
                    
7. An oracle (UMA) confirms: "YES, Bitcoin hit $100k"
                    
8. You redeem your YES tokens  $1.00 each  profit!
</div>
<p>Total time for settlement: ~2 hours after the event (time for oracle confirmation).<br>
Cost per trade: fractions of a penny (Polygon L2).</p>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Further Reading</h2><span class="tgl">+</span></div><div class="sec-b">
<ul>
<li><a href="https://docs.polymarket.com/" target="_blank">Polymarket Documentation</a></li>
<li><a href="https://docs.gnosis.io/conditionaltokens/" target="_blank">Gnosis Conditional Token Framework</a></li>
<li><a href="https://www.paradigm.xyz/2024/11/pm-amm" target="_blank">pm-AMM Paper (Paradigm)</a></li>
<li><a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-1155/" target="_blank">ERC-1155 Multi-Token Standard</a></li>
</ul>
</div></div>

<!-- DAY 3 EXERCISES -->
<div class="ex-gate" id="ex-3">
<h2>Day 3 Exercises</h2><p>Complete ALL to unlock Day 4.</p>

<div class="ex-item" id="ex-3-1">
<div class="ex-num">Exercise 1 of 5 &mdash; Calculation</div>
<p><strong>A market asks "Will India win the cricket match?" YES is priced at $0.45. What does this imply?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'3-1','a')">a) India has a 45% chance of winning according to the market</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'3-1','b')">b) India has a 55% chance of winning</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'3-1','c')">c) You need $45 to bet</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'3-1','d')">d) 45 people have bet on YES</div>
</div>
<button class="ex-btn" onclick="checkMCQ('3-1','a','Correct! The price of a YES token directly represents the market\'s estimate of probability. $0.45 = 45% implied probability. If you think India has a HIGHER chance than 45%, you should buy YES (it\'s underpriced). If lower, buy NO at $0.55.')">Submit Answer</button>
<div class="ex-fb" id="fb-3-1"></div>
</div>

<div class="ex-item" id="ex-3-2">
<div class="ex-num">Exercise 2 of 5 &mdash; Profit Calculation</div>
<p><strong>You buy 200 YES tokens at $0.35 each for the question "Will it snow in Delhi in December?" It does snow. Calculate: (1) Your total investment, (2) Your total redemption, (3) Your profit.</strong></p>
<textarea class="ex-input" id="inp-3-2" placeholder="(1) Investment: ...\n(2) Redemption: ...\n(3) Profit: ..."></textarea>
<button class="ex-btn" onclick="checkText('3-2',20,'Let\'s check: (1) Investment = 200 tokens  $0.35 = $70. (2) Redemption = 200 winning tokens  $1.00 = $200. (3) Profit = $200 - $70 = $130. That\'s a 186% return! The low price ($0.35) meant the market thought snow in Delhi was unlikely (35%). You bet against the crowd and won big. This is how prediction markets reward people with better information.')">Submit Answer</button>
<div class="ex-fb" id="fb-3-2"></div>
</div>

<div class="ex-item" id="ex-3-3">
<div class="ex-num">Exercise 3 of 5 &mdash; Critical Thinking</div>
<p><strong>Why must YES + NO always equal $1.00? What would happen if YES was $0.60 and NO was $0.30 (total = $0.90)?</strong></p>
<textarea class="ex-input" id="inp-3-3" placeholder="If the prices don't add up to $1.00..."></textarea>
<button class="ex-btn" onclick="checkText('3-3',30,'Great analysis! If YES=$0.60 and NO=$0.30 (total $0.90), a trader could: Buy 1 YES ($0.60) + 1 NO ($0.30) = $0.90 spent. Then MERGE them back into $1.00. Instant $0.10 profit, zero risk! This is called ARBITRAGE. Traders immediately exploit this gap, buying both tokens until prices adjust back to summing to $1.00. This is why the arbitrage mechanism keeps prediction market prices honest and accurate.')">Submit Answer</button>
<div class="ex-fb" id="fb-3-3"></div>
</div>

<div class="ex-item" id="ex-3-4">
<div class="ex-num">Exercise 4 of 5 &mdash; Comparison</div>
<p><strong>Your friend wants to create a prediction market for a niche topic (e.g., "Will my local bakery close this year?") that will have very few traders. Which pricing mechanism should they use: Order Book (CLOB) or LMSR? Explain why.</strong></p>
<textarea class="ex-input" id="inp-3-4" placeholder="For a low-traffic market, the best choice is..."></textarea>
<button class="ex-btn" onclick="checkText('3-4',30,'Exactly right! LMSR is the better choice. An Order Book needs buyers AND sellers to be active simultaneously &mdash; with few traders, you\'d get an empty book and no trading. LMSR acts as an always-on bookmaker that will ALWAYS accept your bet, automatically adjusting the price. The tradeoff: the market creator pays a bounded, known subsidy to provide this liquidity. Think of it as paying rent to keep the betting shop open even when few customers come in.')">Submit Answer</button>
<div class="ex-fb" id="fb-3-4"></div>
</div>

<div class="ex-item" id="ex-3-5">
<div class="ex-num">Exercise 5 of 5 &mdash; Exploration</div>
<p><strong>Visit <a href="https://polymarket.com" target="_blank">polymarket.com</a>. Find a market that interests you. Report:</strong> (1) The question, (2) Current YES price, (3) Total trading volume, (4) When it resolves. Then explain: do YOU agree with the market's probability? Why or why not?</p>
<textarea class="ex-input" id="inp-3-5" placeholder="Market I found: ...\nYES price: ...\nVolume: ...\nResolves: ...\nDo I agree? ..."></textarea>
<button class="ex-btn" onclick="checkText('3-5',40,'Excellent research! You\'ve just done what every prediction market trader does: compare the market\'s implied probability (the YES price) to your own estimate. If you think the market is WRONG, that\'s a trading opportunity. Polymarket has processed over $18 billion in bets using exactly the Conditional Token Framework we studied today. Every YES and NO token on that site is an ERC-1155 token on the Polygon blockchain.')">Submit Answer</button>
<div class="ex-fb" id="fb-3-5"></div>
</div>
</div>

<div class="dnav">
<button onclick="goDay(2)">&larr; Day 2</button>
<button onclick="goDay(4)" id="next-3" disabled>Day 4: Oracles &rarr;</button>
</div>
</div>
<!-- ========== DAY 4 ========== -->
<div class="day" id="day-4">
<div class="dh"><span class="dbg">DAY 4</span><h1>Oracles &mdash; The Referee Problem</h1><p>Blockchain can enforce rules perfectly. But who tells it what happened in the real world?</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>The Oracle Problem: Why Blockchains Are Blind</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Imagine a perfectly fair judge who lives in a sealed room.</strong> This judge follows the law perfectly &mdash; no corruption, no bias. But the judge has no windows, no phone, no internet. She cannot see what's happening in the outside world. Someone needs to TELL her the facts of the case. But who? And how do you make sure they're telling the truth?</p></div>

<p>That sealed-room judge is a <strong>blockchain</strong>. It executes rules perfectly (smart contracts), but it <em>cannot</em> access the outside world. It doesn't know if Team A won, whether it rained, or if Bitcoin hit $100k. It has no way to check Google, call an API, or read the news.</p>

<p><strong>Why not?</strong> Because every computer on the network must get the exact same result. If the contract checked a website, different computers might get different responses (the site could be down, updated, or show different data based on location). This would break consensus.</p>

<p>An <strong>oracle</strong> is the messenger who tells the blockchain what happened in the real world. It's the most critical &mdash; and most dangerous &mdash; piece of a prediction market.</p>

<div class="co co-w"><div class="co-title">Why This Is THE Hardest Problem</div>Your smart contract can be mathematically perfect. Your token system can be flawless. But if the oracle lies about who won the game, the wrong people get paid. <strong>The oracle is the weakest link in any prediction market.</strong></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Three Oracle Approaches</h2><span class="tgl">+</span></div><div class="sec-b">

<h4>1. Centralized Oracle (The Single Referee)</h4>
<div class="analogy"><p><strong>One referee, one whistle.</strong> A single person or company checks the result and reports it to the blockchain. Simple and fast. But what if the referee is biased? Bribed? Drunk? You're trusting one entity with everyone's money.</p></div>
<p>Example: The market admin manually says "YES wins." This is what our Day 2 SimpleBet contract did. <strong>Not acceptable for production.</strong></p>

<h4>2. Decentralized Oracle Network &mdash; Chainlink Style (The Panel of Judges)</h4>
<div class="analogy"><p><strong>Instead of one referee, imagine 21 independent referees</strong> from different countries, each watching a separate camera feed. They each submit their verdict, and the system takes the majority answer. Bribing one referee doesn't work &mdash; you'd need to bribe 11+ out of 21. Each referee puts up a security deposit that they lose if they disagree with the majority (incentive to be honest).</p></div>
<p>Chainlink uses this model. Great for continuous data (prices, scores). Less ideal for subjective questions.</p>

<h4>3. Optimistic Oracle &mdash; UMA Style (The Honor System With Consequences)</h4>
<div class="analogy"><p><strong>Imagine a neighborhood watch.</strong> Anyone can report "I saw the game result: Team A won" and puts down a $750 cash bond. For 2 hours, the report is pinned on the community board. If nobody objects, it's accepted as truth. But if someone says "That's wrong!" and puts down their own $750 bond, the dispute escalates to a community-wide vote. The liar loses their $750.</p></div>
<p><strong>This is how Polymarket works.</strong> In practice, 99%+ of outcomes are obvious and uncontested. The 2-hour challenge is just a safety net.</p>

<div class="dia">Someone proposes: "Team A won" + $750 bond
              
      2-hour challenge window
              
      Nobody objects  Result accepted 
                           Proposer gets bond back + fee
     
      Someone disputes + $750 bond
              
         UMA token holders vote
              
         Loser forfeits $750 to the winner</div>

<h4>4. Augur's Fork System (The Nuclear Option)</h4>
<div class="analogy"><p><strong>Imagine a country where, if citizens can't agree on election results, the country literally splits in two.</strong> Each new country claims THEIR result is correct. Citizens must choose which country to move to (bringing their money/assets). The country with more citizens "wins" and becomes the real one. The other withers.</p></div>
<p>Augur does this at the protocol level. If dispute rounds escalate too far, the entire Augur blockchain forks. Extreme but maximally decentralized.</p>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Comparing Oracles: Which to Use When?</h2><span class="tgl">+</span></div><div class="sec-b">
<table>
<thead><tr><th></th><th>Centralized</th><th>Chainlink</th><th>UMA (Optimistic)</th><th>Augur (Fork)</th></tr></thead>
<tbody>
<tr><td><strong>Analogy</strong></td><td>1 referee</td><td>21 referees</td><td>Honor system + fine</td><td>Country splits</td></tr>
<tr><td><strong>Speed</strong></td><td>Instant</td><td>Seconds-minutes</td><td>~2 hours</td><td>Days-weeks</td></tr>
<tr><td><strong>Trust</strong></td><td>Trust 1 entity</td><td>Trust majority honest</td><td>Trust someone will challenge lies</td><td>Trust economics/game theory</td></tr>
<tr><td><strong>Cost to attack</strong></td><td>Bribe 1 person</td><td>Bribe 11+ nodes</td><td>$750+ (and likely lose)</td><td>Buy majority of all tokens</td></tr>
<tr><td><strong>Best for</strong></td><td>Testing only</td><td>Price feeds, scores</td><td>Event outcomes (prediction markets)</td><td>Ultra-high-stakes disputes</td></tr>
<tr><td><strong>Used by</strong></td><td>Nobody serious</td><td>Most DeFi protocols</td><td><strong>Polymarket</strong></td><td>Augur protocol</td></tr>
</tbody>
</table>

<div class="co co-t"><div class="co-title">Why Polymarket Chose UMA</div>Most prediction market outcomes are obvious: "Did Biden win the election?" has a clear, verifiable answer. Using 21 Chainlink nodes to confirm this is overkill and expensive. UMA's optimistic approach is perfect: assume the obvious answer is correct, and only activate the full dispute mechanism for the rare controversial cases. Fast, cheap, and secure enough for 99% of markets.</div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Further Reading</h2><span class="tgl">+</span></div><div class="sec-b">
<ul>
<li><a href="https://ethereum.org/en/developers/docs/oracles/" target="_blank">Ethereum.org: Oracles</a></li>
<li><a href="https://docs.uma.xyz/" target="_blank">UMA Optimistic Oracle Docs</a></li>
<li><a href="https://docs.chain.link/" target="_blank">Chainlink Documentation</a></li>
<li><a href="https://github.com/Polymarket/uma-ctf-adapter" target="_blank">Polymarket's UMA Adapter (GitHub)</a></li>
</ul>
</div></div>

<!-- DAY 4 EXERCISES -->
<div class="ex-gate" id="ex-4">
<h2>Day 4 Exercises</h2><p>Complete ALL to unlock Day 5.</p>

<div class="ex-item" id="ex-4-1">
<div class="ex-num">Exercise 1 of 4 &mdash; Attack Scenario</div>
<p><strong>You build a prediction market that uses a CENTRALIZED oracle (one admin reports outcomes). A malicious admin places a $10,000 bet on NO, then reports YES as the loser even though YES won. Describe: (1) What happens to users, (2) How UMA's optimistic oracle would prevent this.</strong></p>
<textarea class="ex-input" id="inp-4-1" placeholder="(1) What happens to users: ...\n(2) How UMA prevents this: ..."></textarea>
<button class="ex-btn" onclick="checkText('4-1',40,'Excellent analysis! (1) Users who bet correctly on YES lose their money to the dishonest admin. There\'s no recourse because the smart contract blindly trusts the oracle. (2) With UMA, the admin would have to propose the false result AND post a $750 bond. Any user could dispute within 2 hours by posting their own bond. The dispute goes to UMA token holders who vote on the actual outcome. The lying admin loses their $750 bond, and the correct result is reported. The key difference: NO SINGLE PERSON can unilaterally decide the outcome.')">Submit Answer</button>
<div class="ex-fb" id="fb-4-1"></div>
</div>

<div class="ex-item" id="ex-4-2">
<div class="ex-num">Exercise 2 of 4 &mdash; Game Theory</div>
<p><strong>In Augur's dispute system, each round DOUBLES the required stake. If Round 1 costs 100 REP to dispute, calculate the TOTAL cost for an attacker to win 8 consecutive dispute rounds.</strong> (Hint: 100 + 200 + 400 + ...)</p>
<textarea class="ex-input" id="inp-4-2" placeholder="Round 1: 100\nRound 2: 200\n...\nTotal: ..."></textarea>
<button class="ex-btn" onclick="checkText('4-2',15,'Let\'s verify: 100 + 200 + 400 + 800 + 1,600 + 3,200 + 6,400 + 12,800 = 25,500 REP. That\'s 255x the initial stake! This exponential growth is what makes Augur manipulation-resistant. After just 8 rounds, the cost is already enormous. And honest participants get all the attacker\'s lost stake as a reward, creating a strong economic incentive to catch liars. This is game theory in action: the system makes honesty the most profitable strategy.')">Submit Answer</button>
<div class="ex-fb" id="fb-4-2"></div>
</div>

<div class="ex-item" id="ex-4-3">
<div class="ex-num">Exercise 3 of 4 &mdash; Design Challenge</div>
<p><strong>You're building a prediction market for election outcomes. Design your oracle strategy. Answer: (1) Which oracle type would you choose? (2) What's your data source? (3) What happens if the result is contested (like a recount)? (4) How long do you give for challenges?</strong></p>
<textarea class="ex-input" id="inp-4-3" placeholder="(1) Oracle type: ...\n(2) Data source: ...\n(3) If contested: ...\n(4) Challenge period: ..."></textarea>
<button class="ex-btn" onclick="checkText('4-3',50,'Thoughtful design! A strong approach: (1) UMA Optimistic Oracle &mdash; elections have clear, verifiable outcomes. (2) Official government election commission results (e.g., AP or Reuters calls for US elections). (3) For contested results: extend the challenge period to 7 days; require multiple official sources to agree; allow the market to resolve as \"Invalid\" and refund all bets if no clear winner. (4) 24-48 hours for normal markets; 7 days for elections where recounts may happen. Polymarket actually faced this exact challenge during the 2024 US election and handled it via UMA with extended liveness periods.')">Submit Answer</button>
<div class="ex-fb" id="fb-4-3"></div>
</div>

<div class="ex-item" id="ex-4-4">
<div class="ex-num">Exercise 4 of 4 &mdash; Multiple Choice</div>
<p><strong>Why can't a smart contract just check a website or API to determine if "Team A won"?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'4-4','a')">a) Smart contracts don't have internet access</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'4-4','b')">b) Different nodes might get different responses, breaking consensus</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'4-4','c')">c) The website could change or go down</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'4-4','d')">d) All of the above</div>
</div>
<button class="ex-btn" onclick="checkMCQ('4-4','d','Correct &mdash; all three are real problems! (a) The EVM is a sandboxed environment with no external access. (b) If Node A gets \"Team A won\" but Node B gets a timeout, they\'d compute different states, destroying consensus. (c) Websites are mutable and unreliable. This is exactly why oracles exist as a separate layer: a trusted bridge between the deterministic blockchain and the messy real world.')">Submit Answer</button>
<div class="ex-fb" id="fb-4-4"></div>
</div>
</div>

<div class="dnav">
<button onclick="goDay(3)">&larr; Day 3</button>
<button onclick="goDay(5)" id="next-4" disabled>Day 5: Building Contracts &rarr;</button>
</div>
</div>
<!-- ========== DAY 5 ========== -->
<div class="day" id="day-5">
<div class="dh"><span class="dbg">DAY 5</span><h1>Building a Real Prediction Market Contract</h1><p>From reading code to writing it. Production patterns, security, and testing.</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>The Production Contract (Annotated)</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Here's a production-grade prediction market contract. Every line is explained in plain English.</p>

<div class="analogy"><p><strong>Think of this contract as a self-operating betting shop.</strong> It has a cashier (accepts bets), a vault (holds money), a results board (tracks outcomes), and a payout window (distributes winnings). Once the shop opens, it runs itself with zero human intervention.</p></div>

<pre><code><span class="cm">// The betting shop has an alarm system (ReentrancyGuard)
// that prevents a thief from rushing back in during a payout</span>
<span class="kw">contract</span> <span class="tp">PredictionMarket</span> <span class="kw">is</span> <span class="tp">ReentrancyGuard</span> {

    <span class="cm">// SHOP STATUS: Open, Decided, or Cancelled</span>
    <span class="kw">enum</span> <span class="tp">State</span>  { Active, Resolved, Cancelled }
    <span class="kw">enum</span> <span class="tp">Outcome</span> { Undecided, Yes, No }

    <span class="cm">// SHOP RULES (set at opening, NEVER change after)</span>
    <span class="tp">string</span>  <span class="kw">public</span> question;       <span class="cm">// "Will X happen?"</span>
    <span class="tp">uint256</span> <span class="kw">public</span> resolutionTime;  <span class="cm">// when betting closes</span>
    <span class="tp">address</span> <span class="kw">public</span> oracle;         <span class="cm">// who reports the result</span>
    <span class="tp">IERC20</span>  <span class="kw">public</span> collateral;     <span class="cm">// what currency (USDC)</span>

    <span class="cm">// SHOP STATE (changes as bets come in)</span>
    <span class="tp">State</span>   <span class="kw">public</span> state;
    <span class="tp">Outcome</span> <span class="kw">public</span> winningOutcome;
    <span class="tp">uint256</span> <span class="kw">public</span> yesPool;  <span class="cm">// total $ on YES</span>
    <span class="tp">uint256</span> <span class="kw">public</span> noPool;   <span class="cm">// total $ on NO</span>

    <span class="cm">// CUSTOMER RECORDS</span>
    <span class="kw">mapping</span>(<span class="tp">address</span> =&gt; <span class="tp">uint256</span>) <span class="kw">public</span> yesBets;
    <span class="kw">mapping</span>(<span class="tp">address</span> =&gt; <span class="tp">uint256</span>) <span class="kw">public</span> noBets;
    <span class="kw">mapping</span>(<span class="tp">address</span> =&gt; <span class="tp">bool</span>)    <span class="kw">public</span> claimed;

    <span class="cm">// PLACE A BET (the cashier window)</span>
    <span class="kw">function</span> <span class="fn">placeBet</span>(<span class="tp">bool</span> isYes, <span class="tp">uint256</span> amount)
        <span class="kw">external</span> <span class="fn">nonReentrant</span>  <span class="cm">// alarm: one customer at a time</span>
    {
        <span class="kw">require</span>(state == State.Active, <span class="st">"Shop is closed"</span>);
        <span class="kw">require</span>(block.timestamp &lt; resolutionTime, <span class="st">"Too late"</span>);

        <span class="cm">// Take the customer's money from their wallet</span>
        collateral.transferFrom(msg.sender, <span class="kw">address</span>(<span class="kw">this</span>), amount);

        <span class="cm">// Record which pile they put it in</span>
        <span class="kw">if</span> (isYes) { yesBets[msg.sender] += amount; yesPool += amount; }
        <span class="kw">else</span>       { noBets[msg.sender] += amount;  noPool += amount; }
    }

    <span class="cm">// REPORT THE RESULT (only the oracle/referee can do this)</span>
    <span class="kw">function</span> <span class="fn">resolve</span>(<span class="tp">Outcome</span> _outcome) <span class="kw">external</span> {
        <span class="kw">require</span>(msg.sender == oracle, <span class="st">"Not the referee"</span>);
        <span class="kw">require</span>(state == State.Active, <span class="st">"Already decided"</span>);
        state = State.Resolved;
        winningOutcome = _outcome;
    }

    <span class="cm">// COLLECT WINNINGS (the payout window)</span>
    <span class="kw">function</span> <span class="fn">claimWinnings</span>() <span class="kw">external</span> <span class="fn">nonReentrant</span> {
        <span class="kw">require</span>(state == State.Resolved, <span class="st">"Not decided yet"</span>);
        <span class="kw">require</span>(!claimed[msg.sender], <span class="st">"Already collected"</span>);

        <span class="tp">uint256</span> userBet = winningOutcome == Outcome.Yes
            ? yesBets[msg.sender] : noBets[msg.sender];
        <span class="tp">uint256</span> winPool = winningOutcome == Outcome.Yes
            ? yesPool : noPool;
        <span class="kw">require</span>(userBet &gt; <span class="num">0</span>, <span class="st">"You didn't win"</span>);

        <span class="cm">// CRITICAL: Mark as claimed BEFORE sending money</span>
        <span class="cm">// (This prevents the "double-dip" attack)</span>
        claimed[msg.sender] = <span class="kw">true</span>;

        <span class="cm">// Calculate share: your_bet  (total_pool / winning_pool)</span>
        <span class="tp">uint256</span> payout = (userBet * (yesPool + noPool)) / winPool;
        collateral.transfer(msg.sender, payout);
    }
}</code></pre>

<h4>The Payout Formula Explained</h4>
<div class="analogy"><p><strong>Imagine a pot-luck bet among friends.</strong> 3 people bet $100 on YES. 7 people bet $100 on NO. Total pot: $1,000. YES wins. The 3 YES bettors split the entire $1,000 pot proportionally. Each gets $1,000 / 3 = $333.33. That's a 233% return on their $100 bet!</p>
<p>Formula: <strong>your payout = your bet &times; (total pot / winning side's pot)</strong></p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Security: The Three Golden Rules</h2><span class="tgl">+</span></div><div class="sec-b">

<h4>Rule 1: Checks-Effects-Interactions (CEI)</h4>
<div class="analogy"><p><strong>Imagine a bank teller processing a withdrawal.</strong> The WRONG way: hand the customer cash, THEN update the balance in the computer. If the customer grabs the cash and runs back in line before the computer updates, they could withdraw again! The RIGHT way: (1) CHECK the balance, (2) UPDATE the computer (mark as withdrawn), (3) THEN hand over the cash. Even if the customer runs back in line, the computer already shows "withdrawn."</p></div>
<p>In code: always update your records (claimed = true) BEFORE sending money (transfer). This prevents <strong>reentrancy attacks</strong> &mdash; the #1 cause of smart contract hacks.</p>

<h4>Rule 2: Never Trust a Single Admin</h4>
<div class="analogy"><p><strong>Would you give one person the keys to a $100 million vault?</strong> Use oracles (Day 4), multi-signature wallets (requires 3 of 5 key-holders to approve), and immutable rules set at creation.</p></div>

<h4>Rule 3: Freeze the Rules at Creation</h4>
<div class="analogy"><p><strong>Imagine a casino that can change the payout odds AFTER you've placed your bet.</strong> That's fraud. Smart contracts should "snapshot" all configuration (fees, oracle address, resolution rules) when the market is created. Nobody &mdash; not even the creator &mdash; can change them afterward.</p></div>

<table>
<thead><tr><th>Attack</th><th>What Happens</th><th>Prevention</th></tr></thead>
<tbody>
<tr><td><strong>Reentrancy</strong></td><td>Attacker claims winnings multiple times in one transaction</td><td>CEI pattern + ReentrancyGuard</td></tr>
<tr><td><strong>Admin rug-pull</strong></td><td>Admin changes fees or steals funds</td><td>Freeze config at creation; use multi-sig</td></tr>
<tr><td><strong>Double-claim</strong></td><td>Winner claims payout twice</td><td><code>claimed</code> boolean set BEFORE transfer</td></tr>
<tr><td><strong>Bet after resolution</strong></td><td>User bets knowing the outcome</td><td><code>require(state == Active)</code></td></tr>
<tr><td><strong>Oracle manipulation</strong></td><td>False outcome reported</td><td>Decentralized oracle (UMA/Chainlink)</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Design Patterns: Factory, Proxy, Diamond</h2><span class="tgl">+</span></div><div class="sec-b">

<h4>Factory Pattern (The Market Creator Machine)</h4>
<div class="analogy"><p><strong>A cookie cutter.</strong> Instead of hand-shaping each cookie (deploying each market contract manually), you have a machine (factory contract) that stamps out identical cookies (market contracts) on demand. Each cookie is independent but follows the same recipe.</p></div>

<h4>Proxy Pattern (The Upgradeable Store)</h4>
<div class="analogy"><p><strong>A store with replaceable shelves.</strong> The building (proxy = storage) stays the same, but you can swap out the shelving layout (implementation = logic) without moving to a new building. Customer data stays in the building; only the "how we serve customers" part changes.</p></div>

<h4>Diamond Pattern (The Modular Mall)</h4>
<div class="analogy"><p><strong>A shopping mall with specialized stores.</strong> One entrance (proxy) routes you to the right store (facet) based on what you need. The betting store handles bets. The oracle store handles results. The payout store handles withdrawals. Each can be upgraded independently.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Setting Up &amp; Testing</h2><span class="tgl">+</span></div><div class="sec-b">
<h4>Foundry (Recommended Toolchain)</h4>
<pre><code><span class="cm"># Install</span>
curl -L https://foundry.paradigm.xyz | bash && foundryup

<span class="cm"># Create project</span>
forge init my-prediction-market && <span class="kw">cd</span> my-prediction-market

<span class="cm"># Build, test, check gas usage</span>
forge build
forge test -vvvv          <span class="cm"># verbose output</span>
forge test --gas-report   <span class="cm"># see cost of each function</span></code></pre>

<h4>What to Test</h4>
<ol>
<li><strong>Happy path:</strong> bet &rarr; resolve &rarr; claim &rarr; correct payout</li>
<li><strong>Access control:</strong> non-oracle can't resolve; non-winner can't claim</li>
<li><strong>Edge cases:</strong> betting 0, claiming twice, betting after resolution</li>
<li><strong>Invariant:</strong> total payouts &le; total deposits (no money created from nothing)</li>
<li><strong>Fuzz:</strong> random bet amounts, random outcomes &mdash; contract never breaks</li>
</ol>
</div></div>

<!-- DAY 5 EXERCISES -->
<div class="ex-gate" id="ex-5">
<h2>Day 5 Exercises</h2><p>Complete ALL to unlock Day 6.</p>

<div class="ex-item" id="ex-5-1">
<div class="ex-num">Exercise 1 of 4 &mdash; Payout Calculation</div>
<p><strong>A market has $3,000 in the YES pool and $7,000 in the NO pool. YES wins. You bet $500 on YES. How much do you receive?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'5-1','a')">a) $500</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'5-1','b')">b) $1,667</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'5-1','c')">c) $3,333</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'5-1','d')">d) $10,000</div>
</div>
<button class="ex-btn" onclick="checkMCQ('5-1','b','Correct! Payout = $500  ($10,000 / $3,000) = $500  3.33 = $1,667. Your $500 bet returned $1,667 (a 233% return). The minority side (YES with $3,000) gets a bigger multiplier because fewer people share the total pot ($10,000).')">Submit Answer</button>
<div class="ex-fb" id="fb-5-1"></div>
</div>

<div class="ex-item" id="ex-5-2">
<div class="ex-num">Exercise 2 of 4 &mdash; Security Audit</div>
<p><strong>Find the security vulnerability in this code:</strong></p>
<pre><code><span class="kw">function</span> <span class="fn">claimWinnings</span>() <span class="kw">external</span> {
    <span class="tp">uint256</span> payout = calculatePayout(msg.sender);
    collateral.transfer(msg.sender, payout);  <span class="cm">// send money</span>
    claimed[msg.sender] = <span class="kw">true</span>;               <span class="cm">// then mark as claimed</span>
}</code></pre>
<textarea class="ex-input" id="inp-5-2" placeholder="The vulnerability is..."></textarea>
<button class="ex-btn" onclick="checkText('5-2',20,'Excellent catch! The vulnerability is REENTRANCY. Money is sent (transfer) BEFORE the claimed flag is set to true. A malicious contract could: (1) call claimWinnings(), (2) receive the transfer, (3) in its receive function, immediately call claimWinnings() AGAIN. Since claimed is still false, it passes the check and gets paid twice. Fix: move claimed[msg.sender] = true BEFORE the transfer line. This is the CEI (Checks-Effects-Interactions) pattern.')">Submit Answer</button>
<div class="ex-fb" id="fb-5-2"></div>
</div>

<div class="ex-item" id="ex-5-3">
<div class="ex-num">Exercise 3 of 4 &mdash; Design Choice</div>
<p><strong>You're launching a prediction market platform that will host 1,000+ markets. Which design pattern(s) would you use and why: Factory alone, Factory + Proxy, or Diamond?</strong></p>
<textarea class="ex-input" id="inp-5-3" placeholder="I would choose..."></textarea>
<button class="ex-btn" onclick="checkText('5-3',30,'Great reasoning! Best answer: Factory + Beacon Proxy. The Factory creates new market instances (one per question). The Beacon Proxy lets all markets share the same logic contract &mdash; so if you find a bug, you upgrade the beacon once and ALL 1,000 markets get the fix simultaneously. Without proxies, you\'d need to migrate users\' funds from 1,000 old contracts to 1,000 new ones. Diamond is overkill unless your contract exceeds Ethereum\'s 24KB size limit.')">Submit Answer</button>
<div class="ex-fb" id="fb-5-3"></div>
</div>

<div class="ex-item" id="ex-5-4">
<div class="ex-num">Exercise 4 of 4 &mdash; Hands-On</div>
<p><strong>Install Foundry on your machine and create a new project. Run <code>forge build</code>. Paste the output below to prove you've set up the development environment.</strong></p>
<textarea class="ex-input" id="inp-5-4" placeholder="Output of forge build:\n..."></textarea>
<button class="ex-btn" onclick="checkText('5-4',10,'You now have a working Solidity development environment! Foundry\'s forge is the fastest compiler and test runner in the ecosystem. Next steps: create a src/PredictionMarket.sol file, paste the contract from this lesson, and run forge test to verify it compiles. In Day 6, we\'ll connect this to a real oracle.')">Submit Answer</button>
<div class="ex-fb" id="fb-5-4"></div>
</div>
</div>

<div class="dnav">
<button onclick="goDay(4)">&larr; Day 4</button>
<button onclick="goDay(6)" id="next-5" disabled>Day 6: Tokens &amp; Scaling &rarr;</button>
</div>
</div>
<!-- ========== DAY 6 ========== -->
<div class="day" id="day-6">
<div class="dh"><span class="dbg">DAY 6</span><h1>Tokens, Scaling &amp; DeFi Integration</h1><p>Digital casino chips, express highway lanes, and plugging into the wider crypto ecosystem.</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Token Standards: The Shapes of Digital Money</h2><span class="tgl">+</span></div><div class="sec-b">
<p>A "token" is a digital asset managed by a smart contract. Different standards define how tokens behave.</p>

<h4>ERC-20: The Standard Dollar Bill</h4>
<div class="analogy"><p><strong>Every dollar bill works the same way.</strong> Any shop accepts it. Any ATM dispenses it. You can split $100 into smaller bills. ERC-20 is the universal standard for "fungible" tokens (every unit is identical). USDC, DAI, and most crypto tokens are ERC-20. For prediction markets, USDC (a digital dollar) is the most common collateral.</p></div>

<h4>ERC-721: The Concert Ticket</h4>
<div class="analogy"><p><strong>Each ticket has a unique seat number.</strong> Your Row A Seat 5 is different from Row B Seat 12. ERC-721 tokens are "non-fungible" (NFTs) &mdash; each one is unique. Not directly used in prediction markets, but useful for unique market IDs.</p></div>

<h4>ERC-1155: The Multi-Purpose Gift Card System</h4>
<div class="analogy"><p><strong>Imagine one card that tracks multiple types of credits.</strong> Your card shows: 50 coffee credits, 30 lunch credits, 10 movie credits &mdash; all on one card. ERC-1155 lets ONE contract manage MANY token types. For prediction markets, this is critical: each market needs its own YES and NO tokens. Without ERC-1155, you'd deploy separate contracts for each &mdash; expensive and wasteful.</p></div>

<table>
<thead><tr><th>Standard</th><th>Analogy</th><th>Prediction Market Use</th></tr></thead>
<tbody>
<tr><td><strong>ERC-20</strong></td><td>Dollar bills</td><td>Collateral (USDC) &amp; governance tokens (REP)</td></tr>
<tr><td><strong>ERC-721</strong></td><td>Concert tickets</td><td>Unique market identifiers (rare)</td></tr>
<tr><td><strong>ERC-1155</strong></td><td>Multi-credit card</td><td><strong>YES/NO tokens for all markets</strong> (Polymarket uses this)</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Layer 2 Scaling: The Express Lane</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Ethereum is a busy highway with a $50 toll.</strong> Every car (transaction) must pass through and pay. During rush hour, it's slow and expensive. Layer 2 solutions are <strong>express lanes built alongside the highway</strong>. They process thousands of cars quickly and cheaply, then periodically report a summary back to the main highway for security.</p></div>

<h4>Types of Express Lanes</h4>
<table>
<thead><tr><th>Type</th><th>Analogy</th><th>Examples</th><th>Prediction Market Cost</th></tr></thead>
<tbody>
<tr><td><strong>Optimistic Rollups</strong></td><td>Express lane with honor system &mdash; assume cars are legal unless someone objects</td><td>Arbitrum, Optimism, Base</td><td>~$0.01 per bet</td></tr>
<tr><td><strong>ZK Rollups</strong></td><td>Express lane with a camera &mdash; prove every car is legal with a photo</td><td>zkSync, Polygon zkEVM</td><td>~$0.01 per bet</td></tr>
<tr><td><strong>Sidechains</strong></td><td>A separate road that connects to the highway at exits</td><td>Polygon PoS</td><td>~$0.001 per bet</td></tr>
</tbody>
</table>

<div class="co co-i"><div class="co-title">Why Polymarket Chose Polygon</div>A prediction market needs CHEAP and FAST transactions. If each bet costs $50 (Ethereum L1), only whales can participate. On Polygon, each bet costs $0.001 &mdash; making $1 bets economically viable. Same security model (EVM-compatible), 1000x cheaper.</div>

<h4>If 10,000 bets happen daily, what's the daily gas bill?</h4>
<table>
<thead><tr><th>Chain</th><th>Cost Per Bet</th><th>Daily Cost (10K bets)</th></tr></thead>
<tbody>
<tr><td>Ethereum L1</td><td>~$5.00</td><td><strong>$50,000</strong></td></tr>
<tr><td>Arbitrum</td><td>~$0.01</td><td><strong>$100</strong></td></tr>
<tr><td>Polygon PoS</td><td>~$0.001</td><td><strong>$10</strong></td></tr>
<tr><td>Solana</td><td>~$0.00025</td><td><strong>$2.50</strong></td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Integrating a Real Oracle (UMA Code)</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Here's how you'd connect your prediction market to UMA's oracle:</p>
<pre><code><span class="cm">// Step 1: Ask the oracle "What happened?"</span>
<span class="kw">function</span> <span class="fn">requestResolution</span>() <span class="kw">external</span> {
    <span class="cm">// Anyone can propose an answer + post a $750 bond</span>
    oracle.<span class="fn">assertTruth</span>(
        <span class="st">"The outcome of market XYZ is: YES"</span>,
        msg.sender,        <span class="cm">// who's proposing</span>
        <span class="kw">address</span>(<span class="kw">this</span>),     <span class="cm">// tell ME the result</span>
        <span class="num">7200</span>,              <span class="cm">// 2-hour challenge window</span>
        bondAmount         <span class="cm">// $750 USDC bond</span>
    );
}

<span class="cm">// Step 2: UMA calls us back after 2 hours (if no dispute)</span>
<span class="kw">function</span> <span class="fn">assertionResolvedCallback</span>(
    <span class="tp">bytes32</span> id, <span class="tp">bool</span> truthful
) <span class="kw">external</span> {
    <span class="kw">require</span>(msg.sender == <span class="kw">address</span>(oracle));
    <span class="kw">if</span> (truthful) resolve(Outcome.Yes);
    <span class="kw">else</span>          resolve(Outcome.No);
}</code></pre>

<div class="analogy"><p><strong>It's like submitting a tax return.</strong> You file it (propose an answer). The IRS has a review period (2 hours). If nobody audits you, it's accepted. If someone flags it (disputes), it goes to a full review (UMA token holder vote). The filer or the challenger loses their deposit based on who's right.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>DeFi Composability: Prediction Markets + Other Protocols</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Think of DeFi protocols as LEGO blocks.</strong> Each block does one thing well. Snap them together and you get something bigger than the sum of parts.</p></div>

<h4>1. Yield on Collateral (Money Working While It Waits)</h4>
<p>Normally, $1M in a prediction market just sits idle until resolution. What if it earned interest meanwhile?</p>
<div class="analogy"><p>Like putting your security deposit in a savings account instead of a non-interest-bearing escrow. Drift BET (Solana) does this &mdash; collateral earns lending yield while locked in prediction markets.</p></div>

<h4>2. Trading Outcome Tokens on DEXes</h4>
<p>YES/NO tokens can trade on Uniswap, Raydium, etc. This creates additional liquidity beyond the prediction market's own system.</p>

<h4>3. Borrowing Against Positions</h4>
<p>If you hold YES tokens worth $0.95 (very likely to win), you could use them as collateral for a loan. Get liquidity without selling your winning position.</p>
</div></div>

<!-- DAY 6 EXERCISES -->
<div class="ex-gate" id="ex-6">
<h2>Day 6 Exercises</h2><p>Complete ALL to unlock Day 7.</p>

<div class="ex-item" id="ex-6-1">
<div class="ex-num">Exercise 1 of 4 &mdash; Token Standards</div>
<p><strong>Why does Polymarket use ERC-1155 instead of creating a separate ERC-20 contract for each market's YES and NO tokens?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'6-1','a')">a) ERC-1155 tokens are worth more money</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'6-1','b')">b) One contract manages all token types, saving gas and deployment costs</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'6-1','c')">c) ERC-20 tokens can't be traded</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'6-1','d')">d) ERC-1155 is newer so it must be better</div>
</div>
<button class="ex-btn" onclick="checkMCQ('6-1','b','Correct! With 1,000 markets, ERC-20 would require deploying 2,000 separate contracts (YES + NO for each market). ERC-1155 uses ONE contract with 2,000 token IDs. This saves enormous gas costs, enables batch transfers (move tokens from multiple markets in one transaction), and makes the system much simpler to manage. It\'s the difference between opening 2,000 separate bank accounts vs. having one account with 2,000 sub-ledgers.')">Submit Answer</button>
<div class="ex-fb" id="fb-6-1"></div>
</div>

<div class="ex-item" id="ex-6-2">
<div class="ex-num">Exercise 2 of 4 &mdash; Cost Analysis</div>
<p><strong>Your prediction market processes 50,000 bets per day. Calculate the monthly gas cost on: (1) Ethereum L1 at $5/bet, (2) Polygon at $0.001/bet, (3) Solana at $0.00025/bet. Which would you choose for a startup with a $500/month infrastructure budget?</strong></p>
<textarea class="ex-input" id="inp-6-2" placeholder="(1) Ethereum L1: ...\n(2) Polygon: ...\n(3) Solana: ...\nMy choice: ..."></textarea>
<button class="ex-btn" onclick="checkText('6-2',30,'Let\'s check the math! Monthly = 50,000 bets  30 days = 1.5 million bets. (1) Ethereum L1: 1.5M  $5 = $7,500,000/month. Impossible! (2) Polygon: 1.5M  $0.001 = $1,500/month. Over budget but feasible. (3) Solana: 1.5M  $0.00025 = $375/month. Under budget! For a startup with $500/month, Solana is the clear winner. Polygon is viable if the budget grows. Ethereum L1 is out of the question for high-volume prediction markets.')">Submit Answer</button>
<div class="ex-fb" id="fb-6-2"></div>
</div>

<div class="ex-item" id="ex-6-3">
<div class="ex-num">Exercise 3 of 4 &mdash; Oracle Integration</div>
<p><strong>In the UMA integration code above, what happens if someone proposes the WRONG answer? Walk through the full dispute flow step by step.</strong></p>
<textarea class="ex-input" id="inp-6-3" placeholder="Step 1: Proposer submits wrong answer and...\nStep 2: ...\nStep 3: ..."></textarea>
<button class="ex-btn" onclick="checkText('6-3',30,'Great walkthrough! The full flow: (1) Proposer submits \"YES won\" + $750 bond (but NO actually won). (2) Within 2 hours, someone notices the lie and disputes by posting their own $750 bond saying \"NO won.\" (3) The dispute triggers a UMA token holder vote. Thousands of UMA holders examine the evidence and vote. (4) The vote determines the correct answer: NO won. (5) The original proposer LOSES their $750 bond (given to the disputer as a reward). (6) A new proposal with the correct answer is submitted, and after another liveness period, the market resolves correctly. The key insight: lying costs $750 and gains nothing, while disputing a lie earns $750.')">Submit Answer</button>
<div class="ex-fb" id="fb-6-3"></div>
</div>

<div class="ex-item" id="ex-6-4">
<div class="ex-num">Exercise 4 of 4 &mdash; DeFi Creativity</div>
<p><strong>Imagine you hold 1,000 YES tokens (worth $0.90 each = $900) for a market that resolves in 30 days. Design a DeFi strategy that makes your capital more efficient while you wait. What protocols would you combine?</strong></p>
<textarea class="ex-input" id="inp-6-4" placeholder="My DeFi strategy: ..."></textarea>
<button class="ex-btn" onclick="checkText('6-4',30,'Creative thinking! Strong strategies include: (1) Use YES tokens as collateral on Aave/Compound to borrow USDC, then use that USDC to take more positions in other markets (leveraged exposure). (2) Provide liquidity with your YES tokens on a DEX paired with USDC, earning trading fees while you wait. (3) If a protocol like Drift BET exists, deposit the underlying collateral to earn lending yield automatically. Risk to consider: if the market flips against you and YES drops to $0.20, your collateral position gets liquidated. Leverage amplifies both gains and losses!')">Submit Answer</button>
<div class="ex-fb" id="fb-6-4"></div>
</div>
</div>

<div class="dnav">
<button onclick="goDay(5)">&larr; Day 5</button>
<button onclick="goDay(7)" id="next-6" disabled>Day 7: System Design &rarr;</button>
</div>
</div>
<!-- ========== DAY 7 ========== -->
<div class="day" id="day-7">
<div class="dh"><span class="dbg">DAY 7</span><h1>System Design &mdash; Putting It All Together</h1><p>From smart contracts to a product people can actually use. Full architecture, frontend, and your V1 roadmap.</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>The Full Architecture (Bird's Eye View)</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Think of a prediction market as a restaurant.</strong></p>
<ul>
<li><strong>Frontend</strong> = The dining room (what customers see and interact with)</li>
<li><strong>Off-chain services</strong> = The waitstaff (takes orders, routes them efficiently)</li>
<li><strong>Smart contracts</strong> = The kitchen (follows recipes exactly, no shortcuts)</li>
<li><strong>Oracle</strong> = The food inspector (verifies ingredients are what they claim)</li>
<li><strong>Blockchain</strong> = The building's foundation (unchangeable, holds everything up)</li>
<li><strong>Indexer</strong> = The reservation system (tracks all orders for quick lookup)</li>
</ul></div>

<div class="dia">+-----------------------------------------------------+
|                    DINING ROOM                       |
|   (React/Next.js website + wallet connection)        |
+-----------------------------------------------------+
|                    WAIT STAFF                         |
|   (Order matching server, APIs, metadata)            |
+-----------------------------------------------------+
|                RESERVATION SYSTEM                     |
|   (The Graph / indexer - reads blockchain events)     |
+-----------------------------------------------------+
|                    THE KITCHEN                        |
|  +----------------+  +-------------------------+     |
|  | Market Factory |  | Conditional Tokens      |     |
|  | (creates new   |  | (ERC-1155: YES/NO chips)|     |
|  |  markets)      |  +-------------------------+     |
|  +----------------+  +-------------------------+     |
|  | Individual      |  | Collateral (USDC)       |     |
|  | Market Contracts|  +-------------------------+     |
|  +----------------+                                  |
|         |                                            |
|  +------v--------------------------------------+     |
|  | Food Inspector (UMA / Chainlink Oracle)     |     |
|  +---------------------------------------------+     |
+-----------------------------------------------------+
|                THE FOUNDATION                        |
|   (Polygon / Arbitrum / Base / Solana)               |
+-----------------------------------------------------+</div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Frontend: What Users Actually See</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>The frontend is like an ATM interface.</strong> Behind the screen, complex banking systems process your request. But you just see: "How much do you want to withdraw?" Same for prediction markets: behind the website, smart contracts handle custody, settlement, and payouts. The user just sees: "Buy YES at $0.70."</p></div>

<h4>Key Components</h4>
<ol>
<li><strong>Wallet connection</strong> &mdash; User connects MetaMask/Phantom (like logging in with their digital identity)</li>
<li><strong>Market browser</strong> &mdash; Browse active markets, see prices, volumes, expiration dates</li>
<li><strong>Trading interface</strong> &mdash; Buy/sell YES/NO tokens with one click</li>
<li><strong>Portfolio view</strong> &mdash; See your open positions, P&L, history</li>
<li><strong>Event indexer</strong> &mdash; The Graph reads blockchain events and makes them searchable via GraphQL (like having a search engine for on-chain data)</li>
</ol>

<pre><code><span class="cm">// Reading market data from the blockchain (JavaScript)</span>
<span class="kw">const</span> yesPool = <span class="kw">await</span> client.<span class="fn">readContract</span>({
  address: marketAddress,
  abi: marketABI,
  functionName: <span class="st">'yesPool'</span>
})
<span class="cm">// yesPool might be 500000000000 (500,000 USDC in 6 decimals)</span>

<span class="cm">// Placing a bet (triggers wallet popup for user approval)</span>
<span class="kw">await</span> walletClient.<span class="fn">writeContract</span>({
  address: marketAddress,
  abi: marketABI,
  functionName: <span class="st">'placeBet'</span>,
  args: [<span class="kw">true</span>, <span class="fn">parseUnits</span>(<span class="st">'100'</span>, <span class="num">6</span>)]  <span class="cm">// $100 on YES</span>
})</code></pre>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Design Decisions Checklist</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Every prediction market must make these choices. There's no single right answer &mdash; it depends on your goals.</p>
<table>
<thead><tr><th>Decision</th><th>Options</th><th>Think About It Like...</th></tr></thead>
<tbody>
<tr><td><strong>Chain</strong></td><td>Polygon, Arbitrum, Solana, Base</td><td>Choosing which city to open your restaurant in</td></tr>
<tr><td><strong>Market creation</strong></td><td>Anyone can create vs. only approved creators</td><td>Open mic night vs. curated comedy show</td></tr>
<tr><td><strong>Liquidity</strong></td><td>CLOB, LMSR, CPMM, pm-AMM</td><td>Stock exchange vs. bookmaker vs. pool vs. smart pool</td></tr>
<tr><td><strong>Oracle</strong></td><td>UMA, Chainlink, custom</td><td>Honor system vs. panel of judges vs. DIY referee</td></tr>
<tr><td><strong>Collateral</strong></td><td>USDC, ETH, multi-asset</td><td>Dollars-only casino vs. multi-currency casino</td></tr>
<tr><td><strong>Token standard</strong></td><td>ERC-20 per market vs. ERC-1155</td><td>Separate ticket booth per event vs. universal card</td></tr>
<tr><td><strong>Fees</strong></td><td>% of pool, spread, creation fee</td><td>How the restaurant makes money</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>7 Pitfalls That Kill Prediction Markets</h2><span class="tgl">+</span></div><div class="sec-b">
<ol>
<li><strong>$50 gas fees</strong> &mdash; Use L2. A market where betting costs more than the bet is dead.</li>
<li><strong>Trusting one admin</strong> &mdash; Use decentralized oracles. FTX proved single points of trust fail.</li>
<li><strong>Reentrancy bugs</strong> &mdash; Follow CEI. Over $300M lost to this attack since 2024.</li>
<li><strong>Empty order books</strong> &mdash; Use LMSR for new markets. No liquidity = no traders = dead market.</li>
<li><strong>Over-engineering V1</strong> &mdash; Start simple. Binary markets, USDC, admin oracle for testing. Ship fast, iterate.</li>
<li><strong>Ignoring regulations</strong> &mdash; Prediction markets are regulated. Know your jurisdiction.</li>
<li><strong>Oracle manipulation</strong> &mdash; Never use DEX spot prices. Use TWAPs or human-verified oracles.</li>
</ol>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Your V1 Roadmap</h2><span class="tgl">+</span></div><div class="sec-b">
<h4>Phase 1: Smart Contracts (2 weeks)</h4>
<p>PredictionMarket.sol + Factory + ERC-20 collateral + admin oracle + full test suite + testnet deploy</p>
<h4>Phase 2: Oracle (2 weeks)</h4>
<p>UMA Optimistic Oracle integration + dispute handling + emergency pause</p>
<h4>Phase 3: Frontend (2 weeks)</h4>
<p>Wallet connection + market browser + bet placement + portfolio + event indexing</p>
<h4>Phase 4: Ship (2 weeks)</h4>
<p>Security audit + gas optimization + L2 mainnet deploy + monitoring</p>
</div></div>

<!-- DAY 7 EXERCISES -->
<div class="ex-gate" id="ex-7">
<h2>Day 7 Exercises (Final)</h2><p>Complete ALL to finish the curriculum!</p>

<div class="ex-item" id="ex-7-1">
<div class="ex-num">Exercise 1 of 4 &mdash; System Design</div>
<p><strong>Design a prediction market for IPL cricket matches. Specify: (1) Chain and why, (2) Oracle strategy for reporting match results, (3) Liquidity mechanism, (4) Fee model. Write at least 5-6 sentences.</strong></p>
<textarea class="ex-input" id="inp-7-1" placeholder="My IPL prediction market design:\n(1) Chain: ...\n(2) Oracle: ...\n(3) Liquidity: ...\n(4) Fees: ..."></textarea>
<button class="ex-btn" onclick="checkText('7-1',60,'Excellent system design! A strong approach: (1) Polygon or Solana for low fees (IPL fans will bet small amounts frequently). (2) UMA Optimistic Oracle with CricInfo/ESPN as data source, 4-hour liveness period (matches have definitive results). (3) LMSR for individual match markets (bootstraps liquidity in niche matchups), transitioning to CLOB for popular finals. (4) 1-2% of the winning pool, split between protocol treasury and market creators. This covers all the key architectural decisions we\'ve studied this week!')">Submit Answer</button>
<div class="ex-fb" id="fb-7-1"></div>
</div>

<div class="ex-item" id="ex-7-2">
<div class="ex-num">Exercise 2 of 4 &mdash; Comprehensive Knowledge Check</div>
<p><strong>Explain the complete lifecycle of a $100 bet on Polymarket, from deposit to payout. Mention: USDC, Polygon, CTF, ERC-1155, CLOB, UMA oracle, and redemption.</strong></p>
<textarea class="ex-input" id="inp-7-2" placeholder="Step 1: User deposits USDC...\nStep 2: ...\n..."></textarea>
<button class="ex-btn" onclick="checkText('7-2',60,'Outstanding! The full lifecycle: (1) User deposits USDC from their bank/exchange into their Polygon wallet. (2) They browse markets on Polymarket\'s frontend. (3) They click \"Buy YES at $0.65\"  the CTF (Conditional Token Framework) splits their USDC into YES + NO ERC-1155 tokens. (4) The off-chain CLOB (Central Limit Order Book) matches their buy order with a seller. (5) They now hold YES tokens in their wallet. (6) When the event occurs, anyone can propose the outcome to UMA\'s Optimistic Oracle with a ~$750 bond. (7) After a 2-hour liveness period with no dispute, the outcome is finalized. (8) The user redeems their winning YES tokens for $1.00 each via the CTF. Profit = $1.00 - $0.65 = $0.35 per token. You\'ve just described the entire tech stack of the world\'s largest prediction market!')">Submit Answer</button>
<div class="ex-fb" id="fb-7-2"></div>
</div>

<div class="ex-item" id="ex-7-3">
<div class="ex-num">Exercise 3 of 4 &mdash; Competitive Analysis</div>
<p><strong>Compare Polymarket (Polygon/EVM) and Drift BET (Solana) on: (1) Chain speed/cost, (2) Oracle mechanism, (3) Liquidity approach, (4) Unique advantage. Which would you build on and why?</strong></p>
<textarea class="ex-input" id="inp-7-3" placeholder="Polymarket vs Drift BET:\n(1) Speed/cost: ...\n(2) Oracle: ...\n(3) Liquidity: ...\n(4) Unique advantage: ...\nMy choice: ..."></textarea>
<button class="ex-btn" onclick="checkText('7-3',50,'Great analysis! Key differences: (1) Polygon: ~$0.001/tx, 2s blocks. Solana: ~$0.00025/tx, 0.4s blocks. Solana is 4x cheaper and 5x faster. (2) Polymarket uses UMA Optimistic Oracle. Drift BET integrates with Pyth (Solana-native oracle) for price feeds. (3) Polymarket uses a hybrid CLOB (off-chain matching, on-chain settlement). Drift BET integrates with its existing perpetuals engine. (4) Polymarket: largest liquidity and user base ($18B+ volume). Drift BET: yield on collateral (earn interest while betting). For a new project: Polymarket\'s approach is proven at scale; Solana is cheaper but has a smaller DeFi ecosystem. Choose based on your target market!')">Submit Answer</button>
<div class="ex-fb" id="fb-7-3"></div>
</div>

<div class="ex-item" id="ex-7-4">
<div class="ex-num">Exercise 4 of 4 &mdash; Reflection</div>
<p><strong>You started this curriculum 7 days ago. In your own words, explain to a friend who knows nothing about crypto: (1) What is blockchain? (2) What is a prediction market? (3) Why build prediction markets on blockchain? Use only real-world analogies, no jargon.</strong></p>
<textarea class="ex-input" id="inp-7-4" placeholder="Hey [friend's name], let me explain what I've been learning...\n\n(1) Blockchain is like...\n(2) A prediction market is like...\n(3) Combining them is powerful because..."></textarea>
<button class="ex-btn" onclick="checkText('7-4',80,'CONGRATULATIONS! You\'ve completed the entire curriculum!  If you can explain these three concepts to a non-technical friend using only analogies, you truly understand the material. You now know: how blockchains work (shared notebooks), how smart contracts enforce rules (vending machines), how prediction markets discover probabilities (stock exchanges for beliefs), how oracles bridge the real world (referees), how tokens represent positions (casino chips), how L2s make it affordable (express lanes), and how to design a complete system. You\'re ready to build. Go ship something!')">Submit Answer</button>
<div class="ex-fb" id="fb-7-4"></div>
</div>
</div>

<div class="dnav">
<button onclick="goDay(6)">&larr; Day 6</button>
<button onclick="goDay(8)" id="next-7" disabled>Day 8: On/Off Ramp Payments &rarr;</button>
</div>
</div>

<!-- ========== DAY 8 ========== -->
<div class="day" id="day-8">
<div class="dh"><span class="dbg">DAY 8 &bull; BONUS</span><h1>On-Ramp &amp; Off-Ramp &mdash; The Bridge Between Your Bank and the Blockchain</h1><p>How does real money (dollars, rupees, euros) get into crypto and back out? The complete payments pipeline.</p></div>

<div class="sec open"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>The Core Problem: Two Different Worlds</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Imagine you're at an international airport.</strong> You have Indian Rupees, but the country you're visiting only accepts Euros. You need a <strong>currency exchange counter</strong> at the airport. You hand over Rupees, show your passport (identity verification), pay a small fee, and receive Euros. When you return home, you do the reverse: Euros back to Rupees.</p>
<p><strong>On-ramp = the currency exchange counter at departure</strong> (fiat &rarr; crypto).<br>
<strong>Off-ramp = the currency exchange counter at arrival</strong> (crypto &rarr; fiat).</p></div>

<p>The blockchain world runs on crypto (ETH, USDC, SOL). Your bank account holds fiat (USD, INR, EUR). These two systems <strong>don't natively talk to each other</strong>. On-ramps and off-ramps are the bridges that connect them.</p>

<h4>Why Can't You Just "Send" Dollars to a Blockchain?</h4>
<p>Because traditional banks and blockchains speak completely different languages:</p>
<table>
<thead><tr><th></th><th>Traditional Banking</th><th>Blockchain</th></tr></thead>
<tbody>
<tr><td><strong>Identity</strong></td><td>Name, account number, SSN</td><td>Cryptographic wallet address (0x...)</td></tr>
<tr><td><strong>Currency</strong></td><td>USD, EUR, INR (government-issued)</td><td>ETH, USDC, SOL (digital tokens)</td></tr>
<tr><td><strong>Settlement</strong></td><td>1-3 business days (ACH, SWIFT)</td><td>Seconds to minutes</td></tr>
<tr><td><strong>Gatekeepers</strong></td><td>Banks, card networks (Visa/Mastercard)</td><td>Nobody &mdash; permissionless</td></tr>
<tr><td><strong>Reversals</strong></td><td>Chargebacks, disputes possible</td><td>Transactions are final and irreversible</td></tr>
</tbody>
</table>

<div class="co co-w"><div class="co-title">The Chargeback Problem</div>This mismatch creates a fundamental tension: if you buy crypto with a credit card and then do a chargeback, the on-ramp provider loses money because the crypto transaction is irreversible. This is why on-ramp fees are higher for credit cards (~4.5%) vs. bank transfers (~1%) &mdash; the provider charges more to cover fraud risk.</div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>On-Ramp: Getting Money INTO Crypto</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Think of an on-ramp like an ATM in reverse.</strong> At a normal ATM, you insert your card and get cash. With an on-ramp, you insert your payment (card, bank transfer, UPI) and get crypto deposited into your digital wallet. The on-ramp provider handles the messy conversion in the middle.</p></div>

<h4>The Complete On-Ramp Flow (Step by Step)</h4>
<div class="dia">1. USER: "I want to buy $100 of USDC on Polygon"
          
2. ON-RAMP WIDGET: Appears in the dApp (like a checkout form)
   User enters payment details (card number, bank login, UPI ID)
          
3. KYC CHECK: Provider verifies identity
   - First time: Upload government ID + selfie (takes 2-5 min)
   - Returning user: Already verified (instant)
          
4. PAYMENT PROCESSING: Provider charges user's bank/card
   - Card: $100 + $4.50 fee = $104.50 charged
   - Bank transfer: $100 + $1.00 fee = $101.00 charged
          
5. CRYPTO PURCHASE: Provider buys/mints USDC on the open market
          
6. DELIVERY: $100 USDC sent to user's wallet on Polygon
   Transaction visible on-chain within minutes
          
7. READY: User can now trade on Polymarket, Uniswap, etc.</div>

<h4>Payment Methods Compared</h4>
<table>
<thead><tr><th>Method</th><th>Speed</th><th>Typical Fee</th><th>Availability</th><th>Best For</th></tr></thead>
<tbody>
<tr><td><strong>Debit/Credit Card</strong></td><td>Minutes</td><td>3.5-4.5%</td><td>Global (Visa/MC)</td><td>First-time users who want instant access</td></tr>
<tr><td><strong>Bank Transfer (ACH/SEPA)</strong></td><td>1-3 days</td><td>0.5-1%</td><td>US (ACH), EU (SEPA)</td><td>Cost-conscious users who can wait</td></tr>
<tr><td><strong>UPI</strong></td><td>Instant</td><td>1-2%</td><td>India</td><td>Indian users (instant + cheap)</td></tr>
<tr><td><strong>Apple Pay / Google Pay</strong></td><td>Minutes</td><td>~3.5%</td><td>US, EU, UK</td><td>Mobile-native users</td></tr>
<tr><td><strong>SEPA Instant</strong></td><td>Seconds</td><td>~0.5%</td><td>EU</td><td>European users wanting speed + low cost</td></tr>
<tr><td><strong>PIX</strong></td><td>Instant</td><td>~1%</td><td>Brazil</td><td>Brazilian users</td></tr>
<tr><td><strong>Exchange Transfer</strong></td><td>Minutes</td><td>Withdrawal fee only</td><td>Global</td><td>Users with existing Coinbase/Binance accounts</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Off-Ramp: Getting Money OUT of Crypto</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Think of off-ramping like cashing in casino chips.</strong> You've been playing all night (trading on-chain), and now you want to leave with real money. You walk to the cashier, hand over your chips (USDC tokens), show your player card (KYC), and the cashier counts out dollar bills (bank deposit) into your hand.</p></div>

<h4>The Complete Off-Ramp Flow</h4>
<div class="dia">1. USER: Has $5,000 USDC in their Polygon wallet
          
2. INITIATE: User clicks "Withdraw to bank" on the platform
   Or sends USDC to off-ramp provider's address
          
3. PROVIDER: Receives USDC on-chain (irreversible, confirmed in seconds)
          
4. CONVERSION: Provider sells USDC for fiat on the open market
          
5. BANK TRANSFER: Provider sends fiat to user's linked bank account
   - ACH: 1-4 business days
   - Wire transfer: Same day or next business day
   - Debit card push: 3-4 business days
          
6. RECEIVED: $4,950 arrives in user's bank account
   ($50 fee for off-ramp service at ~1%)</div>

<div class="co co-i"><div class="co-title">Why Off-Ramp Is Easier Than On-Ramp</div>Off-ramping has lower fraud risk because the user sends crypto FIRST (irreversible), then receives fiat. The provider already has the crypto in hand before sending money. This is why off-ramp fees (1%) are generally lower than on-ramp card fees (4.5%).</div>

<h4>How Polymarket Handles Withdrawals</h4>
<table>
<thead><tr><th>Method</th><th>Speed</th><th>Fee</th><th>Available To</th></tr></thead>
<tbody>
<tr><td><strong>Debit card push</strong></td><td>3-4 business days</td><td>Free</td><td>Polymarket US users</td></tr>
<tr><td><strong>ACH to bank</strong></td><td>1-4 business days</td><td>Free</td><td>Polymarket US users</td></tr>
<tr><td><strong>Wire transfer</strong></td><td>1 business day</td><td>Free</td><td>Polymarket US users</td></tr>
<tr><td><strong>USDC to wallet</strong></td><td>Minutes</td><td>Gas only (~$0.01)</td><td>All users globally</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Stablecoins: The Secret Sauce of On/Off Ramps</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Stablecoins are like airport lounge vouchers denominated in US dollars.</strong> Whether you came from India (rupees), Japan (yen), or Brazil (reais), once you exchange into these vouchers, everyone speaks the same "dollar" language inside the airport. The voucher is always worth $1.00, no matter what's happening to Bitcoin or Ethereum's price.</p></div>

<p>Stablecoins are the <strong>backbone</strong> of the on/off-ramp ecosystem. In 2025, stablecoin transactions hit <strong>$33 trillion</strong> in total volume &mdash; more than Visa and Mastercard combined.</p>

<h4>The Two Giants</h4>
<table>
<thead><tr><th></th><th>USDC (Circle)</th><th>USDT (Tether)</th></tr></thead>
<tbody>
<tr><td><strong>Market Cap</strong></td><td>~$73 billion</td><td>~$175 billion</td></tr>
<tr><td><strong>Backing</strong></td><td>US Treasuries + cash (fully audited)</td><td>Commercial paper + reserves (less transparent)</td></tr>
<tr><td><strong>Regulated?</strong></td><td>Yes &mdash; US-regulated, monthly attestations</td><td>Loosely &mdash; based in BVI, less oversight</td></tr>
<tr><td><strong>Best for</strong></td><td>Institutions, DeFi, prediction markets</td><td>Trading pairs, emerging markets, remittances</td></tr>
<tr><td><strong>Used by</strong></td><td><strong>Polymarket</strong>, Coinbase, Stripe</td><td>Binance, Tron ecosystem, OTC desks</td></tr>
</tbody>
</table>

<h4>Why Prediction Markets Use USDC (Not ETH or BTC)</h4>
<div class="analogy"><p><strong>Imagine betting $100 on a football match, but the "dollars" you used to bet change value every minute.</strong> You bet "$100" but by the time the game ends, your "$100" might be worth $85 or $120 depending on crypto market moves. You win the bet but lose money because ETH dropped 20%. Stablecoins eliminate this problem &mdash; $1 USDC = $1.00, always.</p></div>

<div class="dia">WHY STABLECOINS DOMINATE THE ON/OFF-RAMP FLOW:

ON-RAMP:                                 OFF-RAMP:
  Rupees  USDC                          USDC  Dollars
  Euros   USDC              USDC  Euros
  Dollars  USDC  BLOCKCHAIN USDC  USDC  Rupees
  Reais   USDC     (DeFi,   
  Yen     USDC     Betting, 
                       Trading) 
                      

  USDC is the "universal language" inside the blockchain</div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Major On-Ramp Platforms: The Complete Landscape</h2><span class="tgl">+</span></div><div class="sec-b">

<h4>Tier 1: Global Leaders</h4>

<h4>MoonPay &mdash; "The Shopify of Crypto Payments"</h4>
<div class="analogy"><p><strong>Like a universal checkout widget.</strong> Just as Shopify lets any store accept payments with a few lines of code, MoonPay lets any dApp let users buy crypto. Used by Polymarket, OpenSea, Uniswap, and 2,000+ partners. Covers 160+ countries.</p></div>
<ul>
<li><strong>Fees:</strong> ~4.5% for cards, ~1% for bank transfers, $3.99 minimum</li>
<li><strong>Supports:</strong> 100+ cryptocurrencies, Visa, Mastercard, Apple Pay, Samsung Pay, bank transfers</li>
<li><strong>Integration:</strong> Widget, SDK (React, iOS, Android), API</li>
<li><strong>KYC:</strong> Handled by MoonPay &mdash; ID + selfie for first-time users</li>
<li><strong>Off-ramp:</strong> Yes &mdash; sell crypto back to fiat at ~1%</li>
</ul>

<h4>Transak &mdash; "Best for Global Coverage &amp; UPI"</h4>
<div class="analogy"><p><strong>Like a payment gateway that speaks every local language.</strong> While MoonPay focuses on cards, Transak excels at local payment methods &mdash; including UPI (India), SEPA Instant (EU), and 20+ regional methods.</p></div>
<ul>
<li><strong>Fees:</strong> 1-5% (varies by region and method)</li>
<li><strong>Supports:</strong> 136+ cryptos, <strong>UPI</strong>, cards, bank transfer, Apple Pay, Google Pay</li>
<li><strong>Integration:</strong> Widget, SDK (React, React Native, Flutter, Unity)</li>
<li><strong>Best for:</strong> dApps targeting Indian users (UPI support) and gaming (Unity SDK)</li>
<li><strong>Off-ramp:</strong> Yes</li>
</ul>

<h4>Ramp Network &mdash; "Developer-First, Cheapest Bank Transfers"</h4>
<div class="analogy"><p><strong>Like Stripe for crypto.</strong> Clean API, excellent docs, transparent pricing. Ramp has the lowest bank transfer fees in the industry at 0.49%.</p></div>
<ul>
<li><strong>Fees:</strong> ~2.9% cards, <strong>~0.49% bank transfers</strong> (industry-lowest)</li>
<li><strong>Supports:</strong> 100+ cryptos, 150+ countries, PIX (Brazil), SPEI (Mexico), Open Banking (UK/EU)</li>
<li><strong>Integration:</strong> Widget, SDK (JS, React, iOS, Android)</li>
<li><strong>Off-ramp:</strong> Yes</li>
</ul>

<h4>Coinbase Onramp &mdash; "The Apple Ecosystem Play"</h4>
<div class="analogy"><p><strong>Like Apple Pay for crypto.</strong> Coinbase Onramp has a unique <strong>Headless API</strong> that lets developers build completely custom UIs. Users can buy crypto with Apple Pay without even having a Coinbase account (guest checkout up to $500/week). Coinbase handles all KYC, fraud, and compliance behind the scenes.</p></div>
<ul>
<li><strong>Fees:</strong> Varies (competitive with Coinbase exchange rates)</li>
<li><strong>Unique:</strong> <strong>Headless API</strong> (full UI control), Apple Pay guest checkout, no developer fees</li>
<li><strong>Integration:</strong> Widget, React (OnchainKit FundCard), Headless API, one-click-buy URL</li>
<li><strong>Off-ramp:</strong> Via Coinbase exchange</li>
</ul>

<h4>Stripe Crypto Onramp &mdash; "Enterprise-Grade"</h4>
<div class="analogy"><p><strong>Like hiring a full-service compliance department.</strong> Stripe handles KYC, fraud detection, payment processing, AND crypto delivery. The dApp developer never touches user payment data or identity info. If your app already uses Stripe, adding crypto on-ramp takes hours.</p></div>
<ul>
<li><strong>Fees:</strong> Standard Stripe processing rates</li>
<li><strong>Unique:</strong> Stripe handles ALL compliance &mdash; developer has zero KYC burden</li>
<li><strong>Supports:</strong> Focused on stablecoins (USDC), leverages all Stripe payment methods</li>
<li><strong>Integration:</strong> Embedded widget, Stripe-hosted page, API</li>
<li><strong>Off-ramp:</strong> Not yet (on-ramp only as of early 2026)</li>
</ul>

<h4>Robinhood Connect &mdash; "Leverage Existing Accounts"</h4>
<ul>
<li><strong>Unique:</strong> Users buy crypto using their existing Robinhood account balance &mdash; zero extra KYC</li>
<li><strong>Integration:</strong> Embeddable widget, partnered with MetaMask</li>
<li><strong>Best for:</strong> US users who already have Robinhood accounts</li>
</ul>

<h4>Tier 2: Specialized Players</h4>
<table>
<thead><tr><th>Provider</th><th>Focus</th><th>Standout Feature</th></tr></thead>
<tbody>
<tr><td><strong>Alchemy Pay</strong></td><td>Asia-Pacific</td><td>Visa Ramp Provider, 14 US state licenses</td></tr>
<tr><td><strong>Banxa</strong></td><td>Enterprise compliance</td><td>Bank-grade AML/KYC</td></tr>
<tr><td><strong>Sardine</strong></td><td>Fraud prevention</td><td>AI-powered fraud detection + on-ramp combined</td></tr>
<tr><td><strong>Bitpanda</strong></td><td>EU market</td><td>Fully MiCAR-licensed across EU</td></tr>
</tbody>
</table>

<h4>The Aggregator: Onramper</h4>
<div class="analogy"><p><strong>Like a flight comparison website (Kayak/Skyscanner) for on-ramps.</strong> Instead of choosing one provider, Onramper connects to 30+ providers and routes each transaction to the cheapest/fastest option based on the user's country, payment method, and desired crypto. One integration = access to all providers. Saves users ~2.5% on average.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>How to Integrate an On-Ramp (For Developers)</h2><span class="tgl">+</span></div><div class="sec-b">

<h4>Option 1: Drop-in Widget (Easiest &mdash; 30 minutes)</h4>
<pre><code><span class="cm">&lt;!-- MoonPay widget: add to your dApp --&gt;</span>
&lt;<span class="kw">script</span>&gt;
  <span class="kw">const</span> widget = window.<span class="fn">MoonPayWebSdk</span>.<span class="fn">init</span>({
    flow: <span class="st">'buy'</span>,
    environment: <span class="st">'production'</span>,
    params: {
      apiKey:          <span class="st">'pk_live_YOUR_KEY'</span>,
      currencyCode:    <span class="st">'usdc_polygon'</span>,       <span class="cm">// what to buy</span>
      walletAddress:   <span class="st">'0xUserWallet...'</span>,    <span class="cm">// where to send</span>
      baseCurrencyCode:<span class="st">'usd'</span>,               <span class="cm">// paying with</span>
      baseCurrencyAmount: <span class="st">'100'</span>,            <span class="cm">// $100 worth</span>
    }
  });
  widget.<span class="fn">show</span>();  <span class="cm">// opens the MoonPay checkout popup</span>
&lt;/<span class="kw">script</span>&gt;</code></pre>

<h4>Option 2: Coinbase Headless API (Most Customizable)</h4>
<pre><code><span class="cm">// Fully custom UI &mdash; you control every pixel</span>
<span class="cm">// Coinbase handles payment processing in the background</span>

<span class="cm">// 1. Generate a buy quote</span>
<span class="kw">const</span> quote = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="st">'https://api.developer.coinbase.com/onramp/v1/buy/quote'</span>, {
  method: <span class="st">'POST'</span>,
  headers: { <span class="st">'Authorization'</span>: <span class="st">'Bearer YOUR_API_KEY'</span> },
  body: <span class="fn">JSON.stringify</span>({
    purchase_currency: <span class="st">'USDC'</span>,
    purchase_network:  <span class="st">'polygon'</span>,
    payment_amount:    <span class="st">'100.00'</span>,
    payment_currency:  <span class="st">'USD'</span>,
    payment_method:    <span class="st">'APPLE_PAY'</span>
  })
});

<span class="cm">// 2. User pays via Apple Pay (your custom UI)</span>
<span class="cm">// 3. Coinbase delivers USDC to user's wallet</span></code></pre>

<h4>Option 3: Onramper Aggregator (Best Coverage)</h4>
<pre><code><span class="cm">&lt;!-- One widget, 30+ providers, auto-routes to best option --&gt;</span>
&lt;<span class="kw">iframe</span>
  src=<span class="st">"https://buy.onramper.com?apiKey=YOUR_KEY
       &defaultCrypto=USDC
       &defaultFiat=INR
       &wallets=USDC:0xYourWallet"</span>
  width=<span class="st">"400"</span> height=<span class="st">"600"</span>
  allow=<span class="st">"payment"</span>
/&gt;</code></pre>

<h4>Integration Complexity Ranking</h4>
<table>
<thead><tr><th>Approach</th><th>Time to Integrate</th><th>Customization</th><th>Best For</th></tr></thead>
<tbody>
<tr><td><strong>Stripe Hosted Page</strong></td><td>Hours</td><td>Low (Stripe-styled)</td><td>Enterprise apps already on Stripe</td></tr>
<tr><td><strong>Coinbase one-click URL</strong></td><td>Minutes</td><td>Minimal</td><td>Quick prototype / hackathon</td></tr>
<tr><td><strong>Onramper widget</strong></td><td>30 min</td><td>Moderate (theming)</td><td>Global audience, need many providers</td></tr>
<tr><td><strong>MoonPay / Transak widget</strong></td><td>1-2 hours</td><td>Moderate</td><td>Consumer dApps</td></tr>
<tr><td><strong>Coinbase Headless API</strong></td><td>Days-weeks</td><td>Full (your own UI)</td><td>Custom branded experience</td></tr>
</tbody>
</table>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>KYC &amp; Compliance: The Legal Guardrails</h2><span class="tgl">+</span></div><div class="sec-b">
<div class="analogy"><p><strong>Think of KYC like airport security.</strong> Before you can board a flight (access the financial system), you must prove your identity. The more expensive the flight (the larger the transaction), the more checks you go through. Economy (Tier 1): show your ID. First class (Tier 2): show your ID + boarding pass + answer extra questions. Private jet (Institutional): show everything, plus explain where the money came from.</p></div>

<h4>Tiered KYC Levels</h4>
<table>
<thead><tr><th>Tier</th><th>What You Provide</th><th>Typical Limit</th><th>Analogy</th></tr></thead>
<tbody>
<tr><td><strong>Tier 0 (Guest)</strong></td><td>Email only</td><td>$50-500</td><td>Buying a coffee &mdash; no ID needed</td></tr>
<tr><td><strong>Tier 1 (Basic)</strong></td><td>Government ID + selfie</td><td>$5,000-10,000/month</td><td>Opening a bank account</td></tr>
<tr><td><strong>Tier 2 (Enhanced)</strong></td><td>ID + proof of address + source of funds</td><td>$50,000+/month</td><td>Applying for a mortgage</td></tr>
<tr><td><strong>Institutional</strong></td><td>Corporate docs, UBO identification, ongoing monitoring</td><td>Custom</td><td>Company IPO due diligence</td></tr>
</tbody>
</table>

<h4>Key Regulations (2025-2026)</h4>
<div class="co co-i"><div class="co-title">US: GENIUS Act (July 2025)</div>First federal stablecoin framework. Requires stablecoin issuers with $10B+ to get federal oversight. Bans foreign-issued stablecoins that don't meet US standards. Full implementation by July 2026.</div>

<div class="co co-i"><div class="co-title">EU: MiCA (Markets in Crypto-Assets Regulation)</div>Harmonized rules across all 27 EU member states. Requires 1:1 reserve backing for stablecoins, mandatory audits, passporting rights (license in one country, operate in all). Full enforcement deadline: July 1, 2026.</div>

<div class="co co-w"><div class="co-title">Consequences of Non-Compliance</div>Multi-million dollar fines, loss of banking services, asset freezes, and criminal liability for executives. This is why every serious on-ramp provider invests heavily in compliance.</div>

<h4>Who Handles KYC? (The Developer's Perspective)</h4>
<div class="analogy"><p><strong>The best part for developers:</strong> YOU don't have to. Every major on-ramp provider handles KYC themselves. When you embed a MoonPay widget, MoonPay does the identity verification. When you use Stripe Crypto, Stripe does the compliance. You never see or store user identity documents. It's like being a restaurant that accepts credit cards &mdash; Visa handles the fraud, not you.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Polymarket Case Study: The Complete Payment Flow</h2><span class="tgl">+</span></div><div class="sec-b">
<p>Let's trace exactly how money flows through Polymarket &mdash; the world's largest prediction market.</p>

<div class="dia">
ALICE IN CALIFORNIA wants to bet $500 on "Will AI pass the bar exam?"


ON-RAMP (Getting money in):

Option A: MoonPay (in-app card purchase)
  Alice's Visa card $522.50 MoonPay $500 USDC Polygon wallet
  Fee: $22.50 (4.5%)        KYC: ID + selfie (first time)

Option B: Coinbase Pay
  Alice's Coinbase $502 Polygon wallet
  Fee: ~$2 (exchange withdrawal)    KYC: Already done on Coinbase

Option C: Direct transfer (crypto-native)
  Alice's MetaMask $500 USDC Polygon wallet
  Fee: ~$0.01 (gas)         KYC: None needed (wallet-to-wallet)

TRADING (On-chain):

  $500 USDC  Split  500 YES tokens + 500 NO tokens
   Sell 500 NO tokens at $0.35  Receive $175
   Net position: 500 YES tokens, cost basis $325

  [Weeks pass... AI passes the bar exam]

  500 YES tokens  Redeem  $500 USDC
  Profit: $500 - $325 = $175

OFF-RAMP (Getting money out):

  $500 USDC in Polygon wallet

Option A: Polymarket US direct withdrawal
   Wire transfer  $500 in Alice's bank (1 business day, free)

Option B: Exchange route
   Send USDC to Coinbase  Sell for USD  Withdraw to bank
  Fee: ~$1-5         Time: 1-3 days

Option C: Keep as USDC
   Alice keeps $500 USDC for next trade (no off-ramp needed)
</div>

<div class="co co-t"><div class="co-title">Critical Warning</div>Polymarket operates exclusively with <strong>USDC on the Polygon network</strong>. Sending BTC, ETH, or USDC on the wrong network (like Ethereum mainnet) will result in <strong>permanent loss of funds</strong>. Always verify the network before sending.</div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Choosing the Right On-Ramp: Decision Framework</h2><span class="tgl">+</span></div><div class="sec-b">

<table>
<thead><tr><th>If Your Users Are...</th><th>Best Provider</th><th>Why</th></tr></thead>
<tbody>
<tr><td>In <strong>India</strong> (need UPI)</td><td><strong>Transak</strong></td><td>Only major provider with full UPI support</td></tr>
<tr><td>In the <strong>US</strong> (existing Coinbase users)</td><td><strong>Coinbase Onramp</strong></td><td>Zero friction, Apple Pay, guest checkout</td></tr>
<tr><td>In <strong>Europe</strong> (want cheap bank transfers)</td><td><strong>Ramp Network</strong></td><td>0.49% SEPA fees &mdash; industry lowest</td></tr>
<tr><td><strong>Global</strong> (maximum coverage)</td><td><strong>Onramper</strong> (aggregator)</td><td>30+ providers, auto-routes to best option</td></tr>
<tr><td><strong>Enterprise</strong> (need full compliance)</td><td><strong>Stripe Crypto</strong></td><td>Stripe handles everything &mdash; KYC, fraud, payments</td></tr>
<tr><td><strong>Cost-sensitive</strong> (want cheapest)</td><td><strong>Ramp</strong> (bank) or <strong>exchange transfer</strong></td><td>0.49% or exchange withdrawal fee only</td></tr>
<tr><td><strong>Speed-sensitive</strong> (want instant)</td><td><strong>MoonPay</strong> or <strong>Transak</strong> (card)</td><td>Minutes from card charge to USDC in wallet</td></tr>
</tbody>
</table>

<div class="scenario"><p><strong>Building a prediction market for Indian users?</strong> Use <strong>Transak</strong> for UPI on-ramp (instant, ~1% fee), settle on <strong>Polygon</strong> ($0.001 per bet), and let users off-ramp back via Transak to their bank. Total cost for a $100 bet cycle: ~$2 in + ~$1 out = $3 total. That's cheaper than most sports betting platforms.</p></div>
</div></div>

<div class="sec"><div class="sec-h" onclick="this.parentElement.classList.toggle('open')"><h2>Further Reading</h2><span class="tgl">+</span></div><div class="sec-b">
<ul>
<li><a href="https://www.moonpay.com/en-gb/business" target="_blank">MoonPay for Business</a> &mdash; widget integration guide</li>
<li><a href="https://transak.com/integration" target="_blank">Transak Developer Integration</a> &mdash; SDK for React, Flutter, Unity</li>
<li><a href="https://docs.ramp.network/" target="_blank">Ramp Network Docs</a> &mdash; developer-first documentation</li>
<li><a href="https://docs.cdp.coinbase.com/onramp-&-offramp/introduction/welcome" target="_blank">Coinbase Onramp &amp; Offramp Docs</a></li>
<li><a href="https://docs.stripe.com/crypto/onramp" target="_blank">Stripe Crypto Onramp Docs</a></li>
<li><a href="https://www.onramper.com/" target="_blank">Onramper Aggregator</a> &mdash; one widget, 30+ providers</li>
<li><a href="https://docs.polymarket.com/polymarket-learn/get-started/how-to-deposit" target="_blank">Polymarket: How to Deposit</a></li>
<li><a href="https://docs.polymarket.com/polymarket-learn/deposits/how-to-withdraw" target="_blank">Polymarket: How to Withdraw</a></li>
</ul>
</div></div>

<!-- DAY 8 EXERCISES -->
<div class="ex-gate" id="ex-8">
<h2>Day 8 Exercises</h2><p>Complete ALL exercises to finish the Payments module.</p>

<div class="ex-item" id="ex-8-1">
<div class="ex-num">Exercise 1 of 5 &mdash; Multiple Choice</div>
<p><strong>Why are credit card on-ramp fees (~4.5%) so much higher than bank transfer fees (~1%)?</strong></p>
<div class="mcq-opts">
  <div class="mcq-opt" onclick="pickMCQ(this,'8-1','a')">a) Credit cards use more electricity</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'8-1','b')">b) Credit card payments can be reversed (chargebacks) but crypto transactions cannot, so the provider charges more to cover fraud risk</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'8-1','c')">c) Banks are slower so they charge less</div>
  <div class="mcq-opt" onclick="pickMCQ(this,'8-1','d')">d) Credit card companies donate the fees to charity</div>
</div>
<button class="ex-btn" onclick="checkMCQ('8-1','b','Correct! This is the fundamental tension between traditional payments and blockchain. A credit card holder can dispute a charge and get a chargeback (money returned). But the crypto has already been sent and is irreversible on the blockchain. If a fraudster buys $10,000 in USDC with a stolen card and then does a chargeback, the on-ramp provider loses $10,000. The 4.5% fee covers this fraud risk. Bank transfers (ACH/SEPA) have much lower reversal risk, hence lower fees.')">Submit Answer</button>
<div class="ex-fb" id="fb-8-1"></div>
</div>

<div class="ex-item" id="ex-8-2">
<div class="ex-num">Exercise 2 of 5 &mdash; Cost Comparison</div>
<p><strong>You want to put $1,000 into a prediction market. Calculate the actual USDC you'd receive using each method:</strong><br>
(1) MoonPay via credit card (4.5% fee)<br>
(2) Ramp Network via bank transfer (0.49% fee)<br>
(3) Direct USDC transfer from Coinbase (flat $2 withdrawal fee)<br>
Which saves you the most money?</p>
<textarea class="ex-input" id="inp-8-2" placeholder="(1) MoonPay card: $1,000 - ... = ...\n(2) Ramp bank: $1,000 - ... = ...\n(3) Coinbase direct: $1,000 - ... = ...\nBest option: ..."></textarea>
<button class="ex-btn" onclick="checkText('8-2',30,'Let\'s check the math: (1) MoonPay card: $1,000 - $45 fee = $955 USDC received. (2) Ramp bank transfer: $1,000 - $4.90 fee = $995.10 USDC received. (3) Coinbase direct: $1,000 - $2 = $998 USDC received. The Coinbase direct transfer saves you $43 compared to the credit card option! But it requires having an existing Coinbase account with funds. The bank transfer via Ramp is only $2.90 more and doesn\'t require any exchange account. For regular traders, the difference between $955 and $998 over many deposits adds up enormously.')">Submit Answer</button>
<div class="ex-fb" id="fb-8-2"></div>
</div>

<div class="ex-item" id="ex-8-3">
<div class="ex-num">Exercise 3 of 5 &mdash; Architecture Design</div>
<p><strong>You're building a prediction market app targeting users in India, US, and Europe. Design your on-ramp strategy:</strong><br>
(1) Which provider(s) would you integrate?<br>
(2) What payment methods for each region?<br>
(3) How would you handle the fact that Indian users use INR, US users use USD, and European users use EUR?<br>
(4) Would you use a single provider or an aggregator? Why?</p>
<textarea class="ex-input" id="inp-8-3" placeholder="(1) Provider(s): ...\n(2) Payment methods per region: ...\n(3) Multi-currency handling: ...\n(4) Single vs aggregator: ..."></textarea>
<button class="ex-btn" onclick="checkText('8-3',50,'Strong thinking! Best approach: (1) Use Onramper (aggregator) as primary &mdash; one integration covers 30+ providers across all regions. For US power users, add Coinbase Onramp separately (Apple Pay, headless API). (2) India: UPI via Transak (routed by Onramper). US: ACH/Apple Pay via Coinbase or MoonPay. Europe: SEPA Instant via Ramp Network. (3) All currencies convert to USDC at the provider level. Your smart contracts only deal with USDC. The user sees prices in their local currency but the blockchain operates in USDC. (4) Aggregator wins here &mdash; three diverse regions means you need providers with different regional strengths. Onramper auto-routes to the cheapest/best option per user\'s country and payment method.')">Submit Answer</button>
<div class="ex-fb" id="fb-8-3"></div>
</div>

<div class="ex-item" id="ex-8-4">
<div class="ex-num">Exercise 4 of 5 &mdash; Critical Thinking</div>
<p><strong>Your friend says: "Why do we need on-ramp providers at all? Can't users just buy USDC on an exchange and send it directly?" Give them 3 reasons why dedicated on-ramp integration is important for a consumer-facing dApp.</strong></p>
<textarea class="ex-input" id="inp-8-4" placeholder="Reason 1: ...\nReason 2: ...\nReason 3: ..."></textarea>
<button class="ex-btn" onclick="checkText('8-4',40,'Great points! Key reasons: (1) USER EXPERIENCE: Most non-crypto users don\'t have exchange accounts. Asking them to sign up for Coinbase, pass KYC there, buy USDC, learn about Polygon network, and manually transfer is 10+ steps. An embedded on-ramp does it in 3 clicks inside your app. (2) DROP-OFF: Every extra step in a sign-up flow loses 20-40% of users. Going from \"click Buy\" to actually having USDC on the right chain involves account creation, KYC, navigation, network selection, and sending. Most people give up. An embedded widget reduces this to a single flow. (3) NETWORK SAFETY: Regular users WILL send USDC on the wrong network (Ethereum instead of Polygon) and permanently lose funds. Embedded on-ramps are pre-configured to deliver to the correct chain. This prevents costly user errors and support nightmares.')">Submit Answer</button>
<div class="ex-fb" id="fb-8-4"></div>
</div>

<div class="ex-item" id="ex-8-5">
<div class="ex-num">Exercise 5 of 5 &mdash; End-to-End Trace</div>
<p><strong>Trace the COMPLETE payment journey: Rahul in Mumbai wants to bet 5,000 INR on "Will India win the T20 World Cup?" on a Polygon-based prediction market. Describe every step from his UPI app to receiving his winnings back in INR. Include: on-ramp provider, currency conversions, blockchain transactions, oracle resolution, and off-ramp.</strong></p>
<textarea class="ex-input" id="inp-8-5" placeholder="Step 1: Rahul opens the prediction market app...\nStep 2: ...\n...\nFinal step: INR arrives in Rahul's bank account"></textarea>
<button class="ex-btn" onclick="checkText('8-5',80,'Outstanding end-to-end trace! The complete flow: (1) Rahul opens the app, connects his wallet, clicks \"Buy YES\" on the India T20 market. (2) The app opens Transak\'s widget (supports UPI). Rahul enters 5,000 INR. Transak shows: 5,000 INR - 75 INR fee = ~$58.50 USDC. (3) Rahul completes KYC (first time: ID upload + selfie, 2 min). (4) Rahul pays via UPI &mdash; instant debit from his bank. (5) Transak converts INR to USDC and sends ~$58.50 USDC to Rahul\'s Polygon wallet (2-5 min). (6) The app\'s smart contract splits $58.50 into 58.5 YES + 58.5 NO tokens (CTF). (7) The CLOB sells Rahul\'s NO tokens at $0.40 each = $23.40 back. Net cost: $35.10 for 58.5 YES tokens. (8) India wins! UMA oracle confirms the result after 2 hours. (9) Rahul redeems 58.5 YES tokens for $58.50 USDC. Profit: $23.40. (10) Rahul sends $58.50 USDC to Transak off-ramp. (11) Transak converts to INR at market rate minus ~1% fee. (12) ~4,850 INR arrives in Rahul\'s bank account via IMPS/NEFT. Total round-trip cost: ~3% (on-ramp + off-ramp fees). You\'ve just traced the entire tech stack!')">Submit Answer</button>
<div class="ex-fb" id="fb-8-5"></div>
</div>
</div>

<div class="dnav">
<button onclick="goDay(7)">&larr; Day 7</button>
<button disabled id="next-8">Curriculum Complete!</button>
</div>
</div>

</div><!-- /content -->
</div><!-- /main -->

<script>
// === STATE ===
const DAYS = 8;
const EX_COUNTS = {1:5, 2:5, 3:5, 4:4, 5:4, 6:4, 7:4, 8:5};
let state = loadState();

function loadState() {
  try { return JSON.parse(localStorage.getItem('bc-pm-v2') || '{}'); }
  catch(e) { return {}; }
}
function saveState() {
  localStorage.setItem('bc-pm-v2', JSON.stringify(state));
}
function exKey(id) { return 'ex-' + id; }

// === NAVIGATION ===
function goDay(n) {
  document.querySelectorAll('.day').forEach(d => d.classList.remove('active'));
  document.getElementById('day-' + n).classList.add('active');
  document.querySelectorAll('.nav-day').forEach((d,i) => {
    d.classList.remove('active');
    if (i === n) d.classList.add('active');
  });
  document.getElementById('day-lbl').textContent = n === 0 ? 'Overview' : (n === 8 ? 'Day 8 (Bonus)' : 'Day ' + n);
  window.scrollTo({top: 0, behavior: 'smooth'});
  if (window.innerWidth <= 860) document.getElementById('sidebar').classList.remove('visible');
}

// === MCQ ===
function pickMCQ(el, exId, val) {
  if (state[exKey(exId)]) return; // already done
  el.parentElement.querySelectorAll('.mcq-opt').forEach(o => o.classList.remove('selected'));
  el.classList.add('selected');
  el.dataset.val = val;
}

function checkMCQ(exId, correct, explanation) {
  if (state[exKey(exId)]) return;
  const opts = document.querySelectorAll('#ex-' + exId.split('-')[0] + ' #ex-' + exId + ' .mcq-opt');
  let selected = null;
  opts.forEach(o => { if (o.classList.contains('selected')) selected = o; });
  if (!selected) { flash(exId, 'fail', 'Please select an answer first.'); return; }

  const val = selected.dataset.val;
  if (val === correct) {
    selected.classList.remove('selected');
    selected.classList.add('correct');
    flash(exId, 'pass', explanation);
    markDone(exId);
  } else {
    selected.classList.remove('selected');
    selected.classList.add('wrong');
    flash(exId, 'fail', 'Not quite. Try again! Think about the core concept behind this question.');
    setTimeout(() => { selected.classList.remove('wrong'); }, 2000);
  }
}

// === TEXT ===
function checkText(exId, minLen, feedback) {
  if (state[exKey(exId)]) return;
  const inp = document.getElementById('inp-' + exId);
  if (!inp) return;
  const val = inp.value.trim();
  if (val.length < minLen) {
    flash(exId, 'fail', 'Please write a more detailed answer (at least a few sentences). This helps you internalize the concept.');
    return;
  }
  flash(exId, 'info', '<strong>Your answer has been recorded.</strong><br><br><strong>Model answer:</strong> ' + feedback);
  inp.disabled = true;
  markDone(exId);
}

// === FEEDBACK ===
function flash(exId, type, msg) {
  const fb = document.getElementById('fb-' + exId);
  if (!fb) return;
  fb.className = 'ex-fb show ' + type;
  fb.innerHTML = msg;
}

// === COMPLETION ===
function markDone(exId) {
  state[exKey(exId)] = true;
  saveState();
  const item = document.getElementById('ex-' + exId);
  if (item) item.classList.add('completed');
  const btn = item ? item.querySelector('.ex-btn') : null;
  if (btn) { btn.disabled = true; btn.classList.add('submitted'); btn.textContent = 'Completed'; }
  checkDayCompletion(parseInt(exId.split('-')[0]));
  updateProgress();
}

function checkDayCompletion(day) {
  const count = EX_COUNTS[day] || 0;
  let done = 0;
  for (let i = 1; i <= count; i++) {
    if (state[exKey(day + '-' + i)]) done++;
  }
  if (done >= count) {
    state['day-' + day + '-done'] = true;
    saveState();
    // unlock next button
    const nextBtn = document.getElementById('next-' + day);
    if (nextBtn) { nextBtn.disabled = false; nextBtn.classList.remove('locked'); }
    // mark sidebar
    const navEl = document.getElementById('nav-' + day);
    if (navEl) navEl.classList.add('done');
  }
}

function updateProgress() {
  let done = 0;
  for (let d = 1; d <= DAYS; d++) {
    if (state['day-' + d + '-done']) done++;
  }
  const pct = Math.round((done / DAYS) * 100);
  document.getElementById('pfill').style.width = pct + '%';
  document.getElementById('plbl').textContent = done + ' / ' + DAYS + ' days completed' + (done >= DAYS ? '  Congratulations!' : '');
}

// === RESTORE STATE ON LOAD ===
function restoreState() {
  for (let d = 1; d <= DAYS; d++) {
    const count = EX_COUNTS[d] || 0;
    for (let i = 1; i <= count; i++) {
      const id = d + '-' + i;
      if (state[exKey(id)]) {
        const item = document.getElementById('ex-' + id);
        if (item) item.classList.add('completed');
        const btn = item ? item.querySelector('.ex-btn') : null;
        if (btn) { btn.disabled = true; btn.classList.add('submitted'); btn.textContent = 'Completed'; }
        // disable text inputs
        const inp = document.getElementById('inp-' + id);
        if (inp) inp.disabled = true;
      }
    }
    checkDayCompletion(d);
  }
  updateProgress();
}
restoreState();
</script>
</body>
</html>
